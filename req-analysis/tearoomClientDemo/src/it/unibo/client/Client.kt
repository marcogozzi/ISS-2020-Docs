/* Generated by AN DISI Unibo */ 
package it.unibo.client

import it.unibo.kactor.*
import alice.tuprolog.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
	
class Client ( name: String, scope: CoroutineScope  ) : ActorBasicFsm( name, scope ){

	override fun getInitialState() : String{
		return "s0"
	}
	@kotlinx.coroutines.ObsoleteCoroutinesApi
	@kotlinx.coroutines.ExperimentalCoroutinesApi			
	override fun getBody() : (ActorBasicFsm.() -> Unit){
		
				val Maxstaytime = 100000L
				val StartDelay = kotlin.random.Random.nextLong(0, Maxstaytime/2*3)
				var Cid = ""
				var WasItMe = false
				var Debug = false
				val WaitTime = 3000L
		return { //this:ActionBasciFsm
				state("s0") { //this:State
					action { //it:State
						updateResourceRep( "press button to begin..."  
						)
						println("press button to begin...")
						 readLine()  
					}
					 transition( edgeName="goto",targetState="notify", cond=doswitch() )
				}	 
				state("notify") { //this:State
					action { //it:State
						updateResourceRep( "notifying to smartbell"  
						)
						println("notifying to smartbell")
						request("notify", "notify(36)" ,"smartbell" )  
					}
					 transition(edgeName="t00",targetState="entering",cond=whenReply("accept"))
					transition(edgeName="t01",targetState="evalStay",cond=whenReply("full"))
					transition(edgeName="t02",targetState="leave",cond=whenReply("deny"))
				}	 
				state("leave") { //this:State
					action { //it:State
						updateResourceRep( "client $Cid has left the tearoom"  
						)
						println("client $Cid has left the tearoom...")
					}
					 transition( edgeName="goto",targetState="s0", cond=doswitch() )
				}	 
				state("entering") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("accept(CID)"), Term.createTerm("accept(CID)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								 Cid = payloadArg(0)  
						}
						updateResourceRep( "client $Cid about to enter... press button when at table"  
						)
						println("client $Cid about to enter")
					}
					 transition(edgeName="t03",targetState="sitting",cond=whenEvent("attable"))
				}	 
				state("sitting") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("attable(Cid)"), Term.createTerm("attable(Cid)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								if( payloadArg(0) == Cid 
								 ){updateResourceRep( "client $Cid sitting"  
								)
								println("client $Cid sitting")
								 WasItMe = true  
								delay(WaitTime)
								}
								else
								 { WasItMe = false  
								 }
						}
					}
					 transition( edgeName="goto",targetState="ordering", cond=doswitchGuarded({ WasItMe  
					}) )
					transition( edgeName="goto",targetState="waitSitting", cond=doswitchGuarded({! ( WasItMe  
					) }) )
				}	 
				state("waitSitting") { //this:State
					action { //it:State
					}
					 transition(edgeName="t04",targetState="sitting",cond=whenEvent("attable"))
				}	 
				state("ordering") { //this:State
					action { //it:State
						updateResourceRep( "client $Cid placing order"  
						)
						println("client $Cid placing order")
						 if(Debug) println("press button to place order")  
						 if(Debug) readLine()  
						delay(WaitTime)
						forward("placeorder", "placeorder($Cid)" ,"waiter" ) 
					}
					 transition(edgeName="t15",targetState="consuming",cond=whenEvent("delivered"))
				}	 
				state("consuming") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("delivered($Cid)"), Term.createTerm("delivered($Cid)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								updateResourceRep( "client $Cid consuming order... press button to request payment"  
								)
								if(  Debug  
								 ){println("client $Cid consuming order")
								 if(Debug) println("press button to pay")  
								 if(Debug) readLine()  
								}
								else
								 {println("client $Cid consuming order")
								 }
								 WasItMe = true  
								delay(WaitTime)
						}else{
							 WasItMe = false  
						}
					}
					 transition( edgeName="goto",targetState="reqPayment", cond=doswitchGuarded({ WasItMe  
					}) )
					transition( edgeName="goto",targetState="waitConsuming", cond=doswitchGuarded({! ( WasItMe  
					) }) )
				}	 
				state("waitConsuming") { //this:State
					action { //it:State
					}
					 transition(edgeName="t16",targetState="consuming",cond=whenEvent("delivered"))
				}	 
				state("reqPayment") { //this:State
					action { //it:State
						updateResourceRep( "client $Cid requested payment"  
						)
						println("client $Cid requested payment")
						forward("payment", "payment($Cid)" ,"waiter" ) 
					}
					 transition(edgeName="t17",targetState="leaving",cond=whenEvent("paymentOk"))
				}	 
				state("leaving") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("paymentOk(Cid)"), Term.createTerm("paymentOk($Cid)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								updateResourceRep( "client $Cid is about to leave"  
								)
								println("client $Cid leaving")
								 WasItMe = true  
								delay(WaitTime)
						}else{
							 WasItMe = false  
						}
					}
					 transition(edgeName="t18",targetState="leaving",cond=whenEventGuarded("paymentOk",{ ! WasItMe  
					}))
					transition(edgeName="t19",targetState="leave",cond=whenEventGuarded("exitOk",{ WasItMe  
					}))
				}	 
				state("evalStay") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("full(CID,WTIME)"), Term.createTerm("full(Cid,WTIME)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								 Cid = payloadArg(0)  
								updateResourceRep( "client $Cid is waiting for a table"  
								)
								println("client $Cid is waiting for a table")
						}
					}
					 transition(edgeName="t010",targetState="sitting",cond=whenEvent("attable"))
				}	 
			}
		}
}
