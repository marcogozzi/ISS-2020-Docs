<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=windows-1252">
    <style type="text/css">
pre{
    white-space: pre-wrap;
}
body
{
    margin-left:  30px;
    margin-right: 30px;
};
P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3, h4 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
  margin-left: 100px;
	background-color: #e6ccff;
    font-size: 105%;
}

h4 {
  margin-left: 200px;
    background-color: #f0c732;
    font-size: 80%;
	
}
#i {
    color: #ff1010;
}
opt{
      background-color:#e6ccff;
  	font-family: "Arial";
    font-size: 80%;
		font-weight: bold;
    color: #0033cc;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
k{
	font-family: "Arial";
	font-weight: bold;
    color: #990000;
	 
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	 
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	 
}
pre{
	font-family: "Helvetica";
	font-size: 60%;
	background-color: #fcf8c7;
	border: 1px solid blue;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
    min-width: 800px;
		max-width: 1200px;
    font-size: 18px;
}    
div.smallbody{
		width: 800px;
    font-size: 15px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}       
div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
  padding: 5px;
  table-layout: fixed ;
}
th#equalfour {
  width: 25% ;
}   
      
th#equalthree {
  width: 33% ;
}   
    
</style> <title>Esame ISS 2020</title>
  </head>
  <body>
    <!--
    <tt>tag tt</tt> <em>tag em</em> <bc>tag bc</bc> <k>tag      k</k> <ks>tag ks</ks> <kc>tag kc</kc>    <pre>tag pre</pre>    <m>tag m</m>    <div class="req"> div req </div>    <div class="remark"> div remark </div>    <hr>    -->
    <div id="top">
      <h1>Progetto finale ISS 2020 - Sprint 1 </h1>
      <k>There is no code without a project, no project without problem analysis
        and no problem without requirements</k>. </div>
    <div class="body">
      <h2>Introduction <a href="http://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/iss2020LabBo/master/it.unibo.issLabStart/userDocs/TemaFinaleBo20.html"
          target="web" style="font-size:50%">original file here</a></h2>
      <div> The <em>manager</em> of a <em>tearoom</em> intends to regulate the
        access to the service by means of a ddr robot (<em>waiter</em>). <br>
        <br>
        The <em>tearoom</em> is a rectangular room that includes:
        <ul>
          <li>an <em>entrancedoor</em> to enter in the room and an <em>exitdoor</em>
            to exit form it;</li>
          <li>a number <tt>N (N=2)</tt> of <em>teatable</em>;</li>
          <li>a <em>serviceare</em> including a <em>servicedesk</em> at which
            works a <em>barman</em>;</li>
          <li>a <em>hall</em> equipped with a <em>presencedetector</em>, i.e.
            a device (e.g. a sonar) that can detect the presence of a person (or
            some other entity) in it.</li>
        </ul>
        The <em>waiter</em> can freely move along the borders of the tearoom,
        since there are no obstacles there. </div>
      <h2>Requirements</h2>
      <div> The <em>waiter</em> should perform the following tasks:
        <ul>
          <li><em>accept</em> the request of a client to enter in the tearoom if
            there is at least one teatable in the state <em>tableclean</em>,
            i.e. the table is free and has been properly cleaned; </li>
          <li><em>inform</em> the client about the maximum waiting time if there
            is no <em>tableclean</em>;</li>
          <li><em>reach</em> the <em>entrance door</em> and <em>convoy</em>
            the accepted client to the selected teatable;</li>
          <li><em>take</em> the order of the client and transmit it (using a
            wifi-device) to the <em>barman</em>; </li>
          <li><em>serve</em> the client when the <em>barman</em> says that the
            requested drink is ready;</li>
          <li><em>collect</em> the payment from the client when he/she has
            finished to consume or when the <em>maxstaytime</em> is expired;</li>
          <li><em>convoy</em> the client to the <em>exitdoor</em>;</li>
          <li><em>clean</em> the tea-table just freed by the client;</li>
          <li><em>rest</em> at my <em>home</em> when there is nothing to do.</li>
          <li><span style="font-size:80%;"> <opt>Optional</opt>: The <em>waiter</em>
              must open the <em>exitdoor</em> only when the hall is free, i.e.
              it must not open that door if the hall is already engaged by a
              client waiting to enter at the <em>entrancedoor</em>. </span></li>
        </ul>
        Since the room could contain <tt>N</tt> clients at the time, the <em>waiter</em>
        should reduce as much as possible the waiting time of the requests
        coming from each client. </div>
      <div><br>
        <h3>User stories</h3>
        As a <em>client</em>,:
        <ul>
          <li>I intend to <em>notify</em> my interest in <em>entering</em> in
            a <em>safe tearoom</em>, <em>sitting</em> at a free teatable, <em>ordering</em>
            some tea, <em>consuming</em> it (within a limited amount of time <em>maxstaytime</em>)
            <em>paying</em> the service with my credit card and finally <em>leaving</em>
            the room.</li>
          <li>For <em>safe tearoom</em>, I intend a tearoom with clean
            tea-tables posed at a proper distance; the room is populated by
            human clients whose body temperature is less than <tt>37.5</tt>
            degrees. </li>
          <li>I can submit my notification of interest by hitting the <em>smartbell</em>
            located near the <em>entrancedoor</em> that will automatically
            measure my body temperature and send a request message to the <em>waiter</em>,
            by giving to me an unique <em>clientidentifier</em>. </li>
          <li>I my body temperature is ok, but my request cannot be immediately
            satisfied (since the room is full), I will be <em>informed</em> by
            the <em>waiter</em> aabout the maximum waiting time.</li>
        </ul>
        As a <em>manager</em>:
        <ul>
          <li>I intend to be able to see the <em>current state</em> of the <em>tearoom</em>
            by using a browser connected to a web-server associated to the
            application. </li>
        </ul>
      </div>
      <h2>Requirement analysis</h2>
      <br>
      <h3> Scenario </h3>
      <div>
        <ul>
          <li>Sono presenti due tavoli ma solamente un Client alla volta può
            accedere alla tearoom;</li>
          <li>ogni Client che accede al sistema esegue l'intera sequenza di
            azioni nel corretto ordine;</li>
          <li>non vi è limite di tempo per eseguire le azioni;</li>
          <li>nessun task è interrompibile.</li>
        </ul>
      </div>
      <table style="width: 100%;" cellspacing="5" cellpadding="5" border="0">
        <thead>
          <tr>
            <th>Requisito / task</th>
            <th>Descrizione / considerazioni</th>
            <th>Interrompibile</th>
            <th>Movimento</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>notify</td>
            <td style="height: 76px;">La Smartbell deve essere capace di <k>interagire
                con il mondo esterno (H2M device)</k>; possibile interazione tra
              Smartbell e Waiter per verificare stato stanza, deve essere
              seguito da task accept oppure inform</td>
            <td style="background-color: rgba(0, 255, 0, 0.4);">N</td>
            <td style="background-color: rgba(0, 255, 0, 0.4);">N<br>
            </td>
          </tr>
          <tr>
            <td>accept</td>
            <td>Waiter verifica stato della stanza e conferma l'accesso<br>
            </td>
            <td style="background-color: rgba(0, 255, 0, 0.4);">N</td>
            <td style="background-color: rgba(0, 255, 0, 0.4);">N<br>
            </td>
          </tr>
          <tr>
            <td>inform</td>
            <td>Waiter verifica stato della stanza e rimanda l'accesso
              informando sul tempo d'attesa</td>
            <td style="background-color: rgba(0, 255, 0, 0.4);">N</td>
            <td style="background-color: rgba(0, 255, 0, 0.4);">N<br>
            </td>
          </tr>
          <tr>
            <td>reach/convoy</td>
            <td>Comporta un cambiamento di stato della stanza (un tavolo in
              stato tableclean sarà in stato occupato); il Waiter deve recarsi
              alla entrancedoor, poi al tavolo assegnato al Client</td>
            <td style="background-color: rgba(0, 255, 0, 0.4);">N</td>
            <td style="background-color: rgba(255, 0, 0, 0.4);">Y<br>
            </td>
          </tr>
          <tr>
            <td>take</td>
            <td> Il Waiter deve recarsi al tavolo assegnato al Client e
              trasmettere l'ordine al Barman; <k>deve essere presente un
                dispositivo H2M</k> per permettere la comunicazione tra Client e
              Waiter (e.g. app, sito web, comandi vocali, ...); la comunicazione
              avviene tramite Wi-Fi al Barman che è quindi dotato di un
              dispositivo collegato alla rete</td>
            <td style="background-color: rgba(0, 255, 0, 0.4);">N</td>
            <td style="background-color: rgba(255, 0, 0, 0.4);">Y<br>
            </td>
          </tr>
          <tr>
            <td>serve</td>
            <td>Il Waiter deve recarsi dal Barman e poi al tavolo assegnato al
              Client che ha fatto richiesta</td>
            <td style="background-color: rgba(0, 255, 0, 0.4);">N</td>
            <td style="background-color: rgba(255, 0, 0, 0.4);">Y<br>
            </td>
          </tr>
          <tr>
            <td>collect</td>
            <td>Il Waiter deve recarsi al tavolo assegnato al Client </td>
            <td style="background-color: rgba(0, 255, 0, 0.4);">N</td>
            <td style="background-color: rgba(255, 0, 0, 0.4);">Y<br>
            </td>
          </tr>
          <tr>
            <td>convoy/exit</td>
            <td>Il Waiter deve recarsi al tavolo assegnato al Client e poi alla
              exitdoor </td>
            <td style="background-color: rgba(0, 255, 0, 0.4);">N</td>
            <td style="background-color: rgba(255, 0, 0, 0.4);">Y<br>
            </td>
          </tr>
          <tr>
            <td>clean</td>
            <td>Il Waiter deve recarsi ad un tavolo libero ma non pulito;
              l'operazione richiede un tempo non nullo e ha priorità inferiore
              rispetto ad altri task, cioè se si presenta un nuovo task durante
              lo svolgimento allora questo task deve essere fermato; se ne può
              mantenere il progresso in caso di interruzione</td>
            <td style="background-color: rgba(255, 0, 0, 0.4);"><b>Y<br>
              </b></td>
            <td style="background-color: rgba(255, 0, 0, 0.4);">Y<br>
            </td>
          </tr>
          <tr>
            <td>rest</td>
            <td>Non è specificato cosa significhi "nothing to do"; deve essere
              interrotto appena vi è un task da svolgere<br>
            </td>
            <td style="background-color: rgba(255, 0, 0, 0.4);"><b>Y<br>
              </b></td>
            <td style="background-color: rgba(255, 0, 0, 0.4);">Y<br>
            </td>
          </tr>
          <tr>
            <td><opt>hall</opt></td>
            <td>Requisito opzionale<br>
            </td>
            <td>?</td>
            <td><br>
            </td>
          </tr>
          <tr>
            <td>showstate</td>
            <td>Deve riguardare tutte le entità che hanno stato; deve essere
              possibile accedere allo stato attraverso un browser quindi il
              sistema deve esporre un punto di accesso web<br>
            </td>
            <td>?</td>
            <td><br>
            </td>
          </tr>
        </tbody>
      </table>
      <h3> Stato </h3>
      <p> Di seguito l'analisi di cosa costituisca lo stato della tearoom,
        insieme ad alcune possibili rappresentazioni che possono essere <kc>usate
          per definire un test plan.</kc> </p>
      <h4>Cosa</h4>
      <p>L'unica informazione significativa riguardante il cliente presente al
        momento è "unique <em>clientidentifier</em>"; <k><span style="color: #020302;">al
            momento</span> non è presente alcun requisito che richieda o renda
          necessario </k>mantenere le ordinazioni effettuate. </p>
      <p> I clienti e il barman sono esterni al sistema e non è specificato come
        facciano ad interagire con i componenti del sistema: deve essere
        presente un <k>sistema human-to-machine con cui interfacciarsi</k> su
        waiter e smartbell.</p>
      <p>I componenti del sistema devono comunicare a scambio di messaggi in
        quanto distribuiti; possibilmente un messaggio viene elaborato subito,
        altrimenti va accodato ed elaborato a seconda della situazione, cioè a
        seconda dello <em>stato della stanza</em>. </p>
      <table width="100%">
        <thead>
          <tr>
            <th> Caratteristica </th>
            <th> Rappresentazione (prolog)</th>
            <th>Rappresentazione (json)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Cliente: codice<br>
            </td>
            <td>client(Cid, State).<br>
            </td>
            <td>{"name":"client", "cid":"", "state":"" }<br>
            </td>
          </tr>
          <tr>
            <td rowspan="3">Teatable: numero, free/busy, clean/dirty, codice
              cliente se busy<br>
            </td>
            <td>teatable(N, free, clean).<br>
            </td>
            <td>{"name":"teatable", "number":1, "free":true, "clean":true,
              "cid":""}<br>
            </td>
          </tr>
          <tr>
            <td>teatable(N, free, dirty). </td>
            <td>{"name":"teatable", "number":1, "free":true, "clean":false,
              "cid":""}</td>
          </tr>
          <tr>
            <td>teatable(N, busy(Cid), dirty). </td>
            <td>{"name":"teatable", "number":1, "free":false, "clean":?,
              "cid":"1"}</td>
          </tr>
          <tr>
            <td>Hall: occupata/libera<br>
            </td>
            <td>hall(free). oppure hall(busy).<br>
            </td>
            <td>{"name":"hall", "free":true} oppure {"name":"hall",
              "free":false} </td>
          </tr>
          <tr>
            <td>Waiter: posizione e stato logico/task in esecuzione<br>
            </td>
            <td>waiter(Task, Pos).<br>
            </td>
            <td>{"name":"waiter", "position":"", "task":""}<br>
            </td>
          </tr>
        </tbody>
      </table>
      <h4> Dove </h4>
      <p> All'interno del sistema solamente l'<kc>entità Waiter è attiva</kc> e
        può modificare lo stato della stanza; lo stato di Teatable e Hall è
        necessario per soddisfare i requisiti ed è utilizzato solamente del
        Waiter per prendere decisioni riguardanti il prossimo task da compiere.
      </p>
      <kc>Al momento</kc>, delegare al Waiter il mantenimento dell'intero stato
      permette una valutazione più rapida e non rende necessario introdurre
      altri elementi nel sistema.<br>
      <k>In futuro</k>, nel caso in cui si vogliano introdurre altri Waiter,
      questa soluzione non sarà più adeguata per garantire un corretto
      assegnamento dei task e sarà necessario introdurre un <k>elemento
        delegato</k> alla gestione della base di conoscenza e/o&nbsp;
      implementare un <k> algoritmo di coordinamento</k> distribuito tra le
      entità attive.</div>
    <h3> Modello </h3>
    <div>
      <ul>
        <li>Le entità del sistema sono distribuite su nodi distinti quindi
          comunicano a scambio di messaggi tra loro e con i dispositivi H2M di
          clienti e barman;</li>
        <li>Il comportamento del Waiter dipende dallo stato della stanza e dai
          messaggi ricevuti quindi si può rappresentare attraverso un FSM;</li>
        <li>Deve essere presente un server web per mostrare lo stato, quindi lo
          stato del modello deve essere esposto con una rappresentazione formale
          in un protocollo adatto a interazione M2M.</li>
      </ul>
      <p>Il <kc>metamodello qa</kc> permette di esprimere questi concetti:</p>
      <ul>
        <li>I nodi su cui eseguono le entità sono espressi da <em>context</em>;</li>
        <li>Le entità sono epresse da attori (<em>QActor</em> permette di
          rappresentare una entità il cui comportamento è descrivibile tramite
          FSM) perchè comunicano a scambio di messaggi e possono ricevere
          messaggi da entità esterne al sistema (alieni);</li>
        <li>Il server web può ottenere lo stato del sistema interrogando gli
          attori con uno dei protocolli supportati (TCP, CoAP, MQTT).</li>
      </ul>
    </div>
    <h4> Modello qak e KB Prolog</h4>
    <p> La comunicazione avviene mediante Dispatch, Request/Reply e Event con
      semantica definita dalla libreria <em>it.unibo.kactor</em>. Gli elementi
      esterni al sistema (cioè i dispositivi H2M che interagiscono con Client e
      Barman) devono essere interfacciati con il sistema traducendo dal
      linguaggio/notazione del dispositivo a messaggi <em>ApplMsg</em>. </p>
    <p>L'uso di Prolog per la base di conoscenza permette una gestione molto ad
      alto livello e dichiaritiva.</p>
    <p>Per comodità di rappresentazione, i dispositivi H2M vengono sintetizzati
      da <em>QActor</em>; nel sistema reale, si avrebbero due nodi fisici
      aggiuntivi da far interagire con il (software del) Waiter, uno per la
      Smartbell e uno per il Barman.</p>
    <table padding="0px" border="0px">
      <tbody>
        <tr valign="top">
          <td>
            <pre width="50%">System tearoom
mqttBroker "localhost" : 1883 eventTopic "unibo/gozzi/events"

//Client - Smartbell, Entering
Request notify : notify(TEMP)
Reply deny : deny(X)
Reply accept : accept(CID)
Reply full : full(CID, WTIME)

//Smartbell - Waiter, Free Table
Request table : table(CID)
Reply available : available(CID)
Reply full : full(CID, WTIME)
Dispatch clientatentrance : clientatentrance(Cid) // self message

//Client - Waiter - Barman, Requesting+serving tea
Dispatch placeorder : placeorder(CID)
Request relayorder : relayorder(Cid)
Reply orderready : orderready(Cid)
//---------------------------------------------------------
Event delivered : delivered($Cid) 	// for client simulation purpose
Event attable: attable(Cid)			// for client simulation purpose
//---------------------------------------------------------

//Client - Waiter, Requesting payment
Dispatch payment : payment(Cid)
//---------------------------------------------------------
Event paymentOk : paymentOk(Cid)	// for client simulation purpose
Event exitOk : exitOk(Cid)			// for client simulation purpose
//---------------------------------------------------------

Context ctxwaiter ip [host="localhost" port=8050]  			+mqtt
Context ctxsmartbell ip [host="localhost" port=8051]		+mqtt
//Context ctxhall ip [host="localhost" port=8052]			+mqtt
Context ctxbarman ip [host="localhost" port=8056]			+mqtt



//ExternalQActor barman context ctxbarman
QActor barman context ctxbarman{
	
	State s0 initial{
	}
	Transition t0
		whenRequest relayorder -&gt; prepareTea
	
	State prepareTea{
		onMsg( relayorder : relayorder(Cid) ){
			[# val Cid = payloadArg(0) #]
			delay 1000 // time to prepare tea
			replyTo relayorder with orderready : orderready($Cid)
			updateResource [# "tea prepared for $Cid" #]
		}
	}
	Transition t0
		whenRequest relayorder -&gt; prepareTea
}

QActor smartbell context ctxsmartbell{
	
	[# 
		val MaxTemp = 37.5 
		var Cid = 1
	#]
	
	State s0 initial{
		solve( consult("hallKB.pl") )
	}
	Transition t0
		whenRequest notify -&gt; checkTemp
		
	State checkTemp{
		onMsg(notify : notify(Temp)){
			if [# payloadArg(0).toDouble() &lt; MaxTemp #] {
				request waiter -m table : table($Cid) // case (a)
			}
			else{
				replyTo notify with deny : deny(0) //case (b)
			}
		}
	}
	Transition t1
		whenRequest 	notify 		-&gt; checkTemp 	//in case (b)
		whenReply 		available 	-&gt; replyClient 	//in case (a)
		whenReply 		full 		-&gt; replyClient 	//in case (a)
		
	State replyClient{
		onMsg(available : available(CID)){
			replyTo notify with accept : accept($Cid)
		}
		onMsg(full : full(CID,WTIME)){
			[# val WaitTime = payloadArg(0) #]
			replyTo notify with full : full($Cid, $WaitTime)
		}
		[# Cid++ #] //new CID for next Client
	}
	Transition t2
		whenRequest notify -&gt; checkTemp
}

QActor waiter context ctxwaiter {
	
	[#
		val MaxStayTime 	= 100000L	
		val DelayTime 		= 1000L
		val RestWaitTime 	= 5000L
	#]
	
	State s0 initial{
		println("waiter RA-s1 starting")
		discardMsg Off
		solve( consult("tearoomKB-RA-sprint1.pl") )
		
		solve( roomstate(S) ) 
		ifSolved { //Documentation says: #S =&gt; ${getCurSol("S").toString()}
			updateResource[# getCurSol("S").toString() #]
		}
	}
	Transition t0
		whenRequest table -&gt; checkTableAvail
	
	//this state implements requirements "accept" and "inform"
	State checkTableAvail{
		println("waiter checkTableAvail")
		onMsg(table : table(Cid)){
			[# val Cid = payloadArg(0) #]
			solve( occupyHall($Cid) )
			solve( reserveTable(Num, $Cid) )//accept
			ifSolved {
				solve( roomstate(S) ) ifSolved { updateResource[# getCurSol("S").toString() #] }
				replyTo table with available : available($Cid)
				forward waiter -m clientatentrance : clientatentrance($Cid) //so that the waiter will eventually do the "reach" task
			}
			else{//inform
				replyTo table with full : full($Cid, $MaxStayTime)
				solve( freeHall($Cid) )
			}
		}
	}
	Transition t0
		whenMsg clientatentrance -&gt; reach
	
	//this state implements requirement "reach"
	State reach{//goto entrance + goto table
		println("waiter reach")
		onMsg(clientatentrance : clientatentrance(Cid)){
			[# val Cid = payloadArg(0) #]
			delayVar DelayTime //goto entrancedoor
			solve( freeHall($Cid) )
			solve( updateWaiter(X,entrancedoor) ) solve( roomstate(S) ) ifSolved { updateResource[# getCurSol("S").toString() #] }
			
			solve( teatable(Num, reserved($Cid), clean) ) // find reserved table
			[# val TableNum = getCurSol("Num").toString() #]
			delayVar DelayTime //goto reserved table
			solve( updateWaiter(X, teatable($TableNum)) )
			solve( engageTable($TableNum, $Cid) ) // occupy table
			emit attable : attable($Cid)
			solve( roomstate(S) ) ifSolved { updateResource[# getCurSol("S").toString() #] }
		}
	}
	Transition t0
		whenMsg placeorder -&gt; takeOrder
	
	//this state implements requirement "take"
	State takeOrder{//goto table + request relayorder
		println("waiter takeOrder")
		onMsg(placeorder : placeorder(Cid)){
			[# val Cid = payloadArg(0) #]
			solve( teatable(Num, busy($Cid), dirty) ) // find correct table
			[# val TableNum = getCurSol("Num").toString() #]
			delayVar DelayTime //goto correct table
			solve( updateWaiter(X, teatable($TableNum)) ) solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
			
			request barman -m relayorder : relayorder($Cid) //real task BL
		}
	}
	Transition t0
		whenReply orderready -&gt; serveOrder
	
	//this state implements requirement "serve"
	State serveOrder{//goto bar + goto table
		println("waiter serveOrder")
		onMsg(orderready : orderready(Cid)){
			[# val Cid = payloadArg(0) #]
			solve( teatable(Num, busy($Cid), dirty) ) // find correct table
			[# val TableNum = getCurSol("Num").toString() #]
			delayVar DelayTime //goto barman
			
			solve( updateWaiter(X, bar) ) solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
			delayVar DelayTime //goto correct table
			
			solve( updateWaiter(X, teatable($TableNum)) ) solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
			
			//-------------------------------------------
			emit delivered : delivered($Cid) //just for simulation, in real life the client would see that the waiter has brought the tea
			//-------------------------------------------
		}
	}
	Transition t0
		whenMsg payment -&gt; getPayment
	
	//this state implements requirements "collect" and "exit"
	State getPayment{//goto table + goto exitdoor
		println("waiter getPayment")
		onMsg(payment : payment(Cid)){
			[# val Cid = payloadArg(0) #]
			solve( teatable(Num, busy($Cid), dirty) ) // find correct table
			[# val TableNum = getCurSol("Num").toString() #]
			delayVar DelayTime //goto correct table	
			
			emit paymentOk : paymentOk($Cid)
			solve( updateWaiter(X, teatable($TableNum)) ) solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
			
			delayVar DelayTime //goto exitdoor
			emit exitOk : exitOk($Cid)
			solve( updateWaiter(X, exitdoor) ) 
			solve( freeTable($TableNum, $Cid) )
			solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
			}
	}
	Goto cleanTable
	
	State cleanTable{
		println("waiter cleanTable")
		solve( dirtyTable(Num) )
		ifSolved{
			[# val TableNum = getCurSol("Num").toString() #]
			delayVar DelayTime // go to table
			
			solve( updateWaiter(X, teatable($TableNum)) ) solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
			delayVar DelayTime // clean table, waiter cannot process incoming messages
			
			solve( cleanTable($TableNum) )	solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
			
		}
		solve( roomstate(S) ) ifSolved { 
					[#println( "$tt After clean ${getCurSol("S").toString()}" ) #]
					updateResource[# getCurSol("S").toString() #]
			}
	}
	Transition t0
		whenTimeVar RestWaitTime -&gt; rest
		whenRequest table -&gt; checkTableAvail
		
	State rest{
		println("waiter rest")
		delayVar DelayTime
		solve( updateWaiter(X, athome )) solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
	}
	Transition t0
		whenRequest table -&gt; checkTableAvail
	
}
</pre> </td>
          <td>
            <pre style="height: 1164px;">%===========================================
% tearoomkb.pl
%===========================================
 
%% ------------------------------------------ 
%% Teatables
%% teatable(Num, {free, reserved(Cid), busy(Cid)}, {clean, dirty}).
%% ------------------------------------------ 
teatable( 1, free, clean ).
teatable( 2, free, clean ). 

tableavailable(N):- teatable(N,	free, clean ).

numavailabletables(N) :-
	findall( N, teatable( N, free, clean ), NList),
	length( NList, N ).

reserveTable(N,Cid)	 :-
	retract( teatable( N, free, clean ) ) ,
	!,
	assert( teatable( N, reserved(Cid), clean ) ).
	
reserveTable(_,_).	

%%reservedTable(N, Cid, Clean) :- teatable( N, reserved(Cid), Clean ). %%tavolo prenotato da Cid

engageTable(N,Cid)	 :-
	retract( teatable( N, reserved(Cid), clean ) ) ,
	!,
	assert( teatable( N, busy(Cid), dirty ) ).

freeTable(N, Cid) :-
	retract( teatable( N, busy(Cid), dirty ) ),
	!,
	assert( teatable( N, free, dirty ) ).
freeTable(_,_).	
	
dirtyTable(Num) :- teatable(Num, free, dirty).	
	
cleanTable(N)	 :-
	%% stdout &lt;- println( tearoomkb_cleanTable(N) ),
	retract( teatable( N, free, dirty ) ) ,
	!,
	assert( teatable( N, free, clean ) ).
cleanTable(N).	
 
stateOfTeatable( [teatable1(V1,V2)] ) :-
	teatable( 1, V1, V2 ).
	
stateOfTeatables( [teatable(1, V1, V2),teatable(2, V3, V4)] ) :-
	teatable( 1, V1, V2 ),
	teatable( 2, V3, V4 ).

%% ------------------------------------------ 
%% Waiter
%% ------------------------------------------ 

waiter( athome ).	

updateWaiter(Old,New) :- 
	retract(waiter(Old)),
	!,
	assert(waiter(New)).

%% ------------------------------------------ 
%% Hall
%% ------------------------------------------ 
hall(free).

freeHall(X) :- 
retract(hall(free)),
!,
assert(hall(busy)).

occupyHall(X) :- 
retract(hall(busy)),
!,
assert(hall(free)).


%% ------------------------------------------ 
%% Room as a whole
%% ------------------------------------------ 
roomstate(  state( waiter(S), tables(V) )  ):-
	 waiter(S), stateOfTeatables(V) .
	 
	
</pre> </td>
        </tr>
      </tbody>
    </table>
    <br>
    <hr>
    <p>Simulazione di cliente espressa con metamodello qa per interagire con il
      modello.</p>
    <pre style="width: 70%">System tearoomclientsimulation 
mqttBroker "localhost" : 1883 eventTopic "unibo/gozzi/events"


//Client - Smartbell, Entering
Request notify : notify(TEMP)
Reply deny : deny(X)
Reply accept : accept(CID)
Reply full : full(CID, WTIME)

//Client - Waiter - Barman, Requesting+serving tea
Dispatch placeorder : placeorder(CID)
Request relayorder : relayorder(Cid)
Reply orderready : orderready(Cid)
//---------------------------------------------------------
Event delivered : delivered($Cid) // for simulation purpose
Event attable: attable(Cid)			// for client simulation purpose
//---------------------------------------------------------


//Client - Waiter, Requesting payment
Dispatch payment : payment(Cid)
Event paymentOk : paymentOk(Cid)
Event exitOk : exitOk(Cid)

//From web
Event goOn : goOn(x)

Context ctxwaiter ip [host="localhost" port=8050]		+mqtt
Context ctxsmartbell ip [host="localhost" port=8051]	+mqtt
Context ctxclient ip [host="127.0.0.1" port=8055]		+mqtt
//Context ctxclient ip [host="localhost" port=8055]		+mqtt


QActor client context ctxclient{
	
	[#
		val Maxstaytime = 100000L
		val StartDelay = kotlin.random.Random.nextLong(0, Maxstaytime/2*3)
		var Cid = ""
		var WasItMe = false
		var Debug = false
		val WaitTime = 3000L
	#]
	
	State s0 initial{
//		delayVar StartDelay
		updateResource[# "press button to begin..." #]
		println("press button to begin...")
		[# readLine() #]
		
	}
//		Transition t0
//		whenEvent goOn -&gt; notify
	Goto notify
	
	State notify {
		updateResource[# "notifying to smartbell" #]
		println("notifying to smartbell")
		request smartbell -m notify : notify(36)
	}
	Transition t0
//		whenTimeVar Maxstaytime -&gt; leave 
		// me ne vado ancora prima di entrare? posso decidere con una assunzione che non accada -&gt; i.e. ogni cliente che entra non se ne va e aspetta
		whenReply accept 		-&gt; entering
		whenReply full 			-&gt; evalStay
		whenReply deny 			-&gt; leave
		
	State leave{
		updateResource[# "client $Cid has left the tearoom" #]
		println("client $Cid has left the tearoom...")
	}
	Goto s0
	
	State entering{
		onMsg(accept : accept(CID)){
			[# Cid = payloadArg(0) #]
		}
		updateResource[# "client $Cid about to enter... press button when at table" #]
		println("client $Cid about to enter")
	}
	Transition t0
//	whenEvent goOn -&gt; sitting
	whenEvent attable -&gt; sitting
	
	State sitting{
		onMsg(attable : attable(Cid)){
			if [#payloadArg(0) == Cid#]{
			updateResource[# "client $Cid sitting" #]
			println("client $Cid sitting")
			[# WasItMe = true #]
			delayVar WaitTime
			
			}else{
			[# WasItMe = false #]
		}
		}
		
	}
	/*
	Transition t0 whenEvent attable and [# ! WasItMe #] -&gt; sitting
	else Goto ordering
	*/
	Goto ordering if [# WasItMe #] else waitSitting
	State waitSitting{} Transition t0 whenEvent attable -&gt; sitting
		
	State ordering{
		updateResource[# "client $Cid placing order" #]
		println("client $Cid placing order")
		[# if(Debug) println("press button to place order") #]
		[# if(Debug) readLine() #]
		delayVar WaitTime
		forward waiter -m placeorder : placeorder($Cid)
	}
	Transition t1
		whenEvent delivered -&gt; consuming
//Goto consuming
		

	State consuming{
		onMsg(delivered : delivered($Cid)){
			updateResource[# "client $Cid consuming order... press button to request payment" #]
			if [# Debug #]{
				println("client $Cid consuming order")
				[# if(Debug) println("press button to pay") #]
				[# if(Debug) readLine() #]
			}
			else{
				println("client $Cid consuming order")
			}
			[# WasItMe = true #]
			delayVar WaitTime
		}
		else{
			[# WasItMe = false #]
		}
	}
//	Transition t0
//	whenEvent goOn -&gt; reqPayment
	Goto reqPayment if [# WasItMe #] else waitConsuming
	State waitConsuming{} Transition t1 whenEvent delivered -&gt; consuming	
	
	
	State reqPayment{
		updateResource[# "client $Cid requested payment" #]
		println("client $Cid requested payment")
		forward waiter -m payment : payment($Cid)
	}
	Transition t1
		whenEvent paymentOk -&gt; leaving
//Goto leaving
	
	State leaving{
		onMsg(paymentOk : paymentOk($Cid)){
			updateResource[# "client $Cid is about to leave" #]
			println("client $Cid leaving")
			[# WasItMe = true #]
			delayVar WaitTime
		}
		else{
			[# WasItMe = false #]
		}
	}
//	Transition t1
//		whenEvent exitOk -&gt; leave
//Goto leave
	Transition t1 
		whenEvent paymentOk and [# ! WasItMe #] -&gt; leaving	
		whenEvent exitOk and [# WasItMe #] -&gt; leave
	
	State evalStay{ 
		onMsg(full : full(Cid, WTIME)){
			[# Cid = payloadArg(0) #]
//			[# WaitTime = payloadArg(1) #]
			updateResource[# "client $Cid is waiting for a table" #]
			println("client $Cid is waiting for a table")
		}
		
	}
//Goto sitting
	Transition t0
		whenEvent attable -&gt; sitting
	
}


ExternalQActor waiter context ctxwaiter
ExternalQActor smartbell context ctxsmartbell</pre>
    <br>
    <h4> Analisi dei messaggi </h4>
    <br>
    <table border="1" width="100%">
      <thead>
        <tr>
          <th>Message name<br>
          </th>
          <th>Dispatch<br>
          </th>
          <th>Request/Reply<br>
          </th>
          <th>Event<br>
          </th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>notify<br>
          </td>
          <td style="background-color: rgba(255, 0, 0, 0.5);"><br>
          </td>
          <td style="background-color: rgba(0, 254, 0, 0.4);">La smartbell
            riceve una richiesta dal client contenente la temperatura; il client
            deve ricevere una risposta</td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>deny<br>
          </td>
          <td style="background-color: rgba(255, 0, 0, 0.5);">A tempo di
            sviluppo è necessario sapere il destinatario </td>
          <td style="background-color: rgba(0, 254, 0, 0.4);">Risposta a notify
            se temperatura &gt;37.5; non è necessario conoscere chi ha fatto la
            richiesta<br>
          </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>accept<br>
          </td>
          <td style="background-color: rgba(255, 0, 0, 0.5);">A tempo di
            sviluppo è necessario sapere il destinatario</td>
          <td style="background-color: rgba(0, 254, 0, 0.4);">Risposta a notify
            se c'è un teatable disponibile; non è necessario conoscere chi ha
            fatto la richiesta </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>full<br>
          </td>
          <td style="background-color: rgba(255, 0, 0, 0.5);">A tempo di
            sviluppo è necessario sapere il destinatario</td>
          <td style="background-color: rgba(0, 254, 0, 0.4);">Risposta a notify
            se non c'è un teatable disponibile; non è necessario conoscere chi
            ha fatto la richiesta</td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>table<br>
          </td>
          <td style="background-color: #fdfdfd;"><br>
          </td>
          <td style="background-color: rgba(0, 254, 0, 0.4);">La smartbell
            chiede al waiter se c'è un teatable disponibile; la smartbell deve
            ricevere una risposta<br>
          </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>available<br>
          </td>
          <td style="background-color: #fdfdfd;"><br>
          </td>
          <td style="background-color: rgba(0, 254, 0, 0.4);">Risposta a table
            se c'è un teatable disponibile </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>full<br>
          </td>
          <td style="background-color: #fdfdfd;"><br>
          </td>
          <td style="background-color: rgba(0, 254, 0, 0.4);">Risposta a table
            se non c'è un teatable disponibile </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>clientatentrance<br>
          </td>
          <td style="background-color: rgba(0, 254, 0, 0.4);">La smartbell
            informa il&nbsp; waiter che c'è un client in attesa alla
            entrancedoor<br>
          </td>
          <td><br>
          </td>
          <td style="background-color: rgba(255, 0, 0, 0.4);">Se il waiter è in
            uno stato non idoneo il messaggio è perso<br>
          </td>
        </tr>
        <tr>
          <td>attable</td>
          <td style="background-color: rgba(255, 0, 0, 0.4);">Per il waiter il
            client è un alieno</td>
          <td style="background-color: rgba(255, 0, 0, 0.4);">Non è prevista
            risposta, il messaggio è per avvertire di un avvenimento </td>
          <td style="background-color: rgba(0, 255, 0, 0.4);">Solo per
            effettuare la simulazione, il client deve sapere quando è stato
            accompagnato al tavolo </td>
        </tr>
        <tr>
          <td>placeorder<br>
          </td>
          <td style="background-color: rgba(0, 254, 0, 0.4);">Il client informa
            il waiter che è pronto ad effettuare l'ordine<br>
          </td>
          <td style="background-color: rgba(255, 0, 0, 0.4);">Non è prevista
            risposta, il messaggio è per richiedere una azione<br>
          </td>
          <td style="background-color: rgba(255, 0, 0, 0.4);">Se il waiter è in
            uno stato non idoneo il messaggio è perso</td>
        </tr>
        <tr>
          <td>relayorder<br>
          </td>
          <td><br>
          </td>
          <td style="background-color: rgba(0, 254, 0, 0.4);">Il waiter chiede
            al barman di preparare l'ordine per il client<br>
          </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>orderready<br>
          </td>
          <td><br>
          </td>
          <td style="background-color: rgba(0, 254, 0, 0.4);">Il waiter aspetta
            che il barman risponda alla singola richiesta<br>
          </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>payment<br>
          </td>
          <td style="background-color: rgba(0, 254, 0, 0.4);"> Il client informa
            il waiter che è pronto per pagare </td>
          <td style="background-color: rgba(255, 0, 0, 0.4);">Non è prevista
            risposta, il messaggio è per richiedere una azione</td>
          <td style="background-color: rgba(255, 0, 0, 0.4);">Se il waiter è in
            uno stato non idoneo il messaggio è perso</td>
        </tr>
        <tr>
          <td>delivered<br>
          </td>
          <td style="background-color: rgba(255, 0, 0, 0.4);">Per il waiter il
            client è un alieno<br>
          </td>
          <td style="background-color: rgba(255, 0, 0, 0.4);">Non è prevista
            risposta, il messaggio è per avvertire di un avvenimento </td>
          <td style="background-color: rgba(0, 254, 0, 0.4);">Solo per
            effettuare la simulazione, il client deve sapere quando l'ordine gli
            viene consegnato per iniziare a consumarlo<br>
          </td>
        </tr>
        <tr>
          <td>paymentOk<br>
          </td>
          <td style="background-color: rgba(255, 0, 0, 0.4);">Per il waiter il
            client è un alieno</td>
          <td style="background-color: rgba(255, 0, 0, 0.4);">Non è prevista
            risposta, il messaggio è per avvertire di un avvenimento </td>
          <td style="background-color: rgba(0, 254, 0, 0.4);">Solo per
            effettuare la simulazione, il client deve sapere quando il pagamento
            è andato a buon fine</td>
        </tr>
        <tr>
          <td>exitOk<br>
          </td>
          <td style="background-color: rgba(255, 0, 0, 0.4);">Per il waiter il
            client è un alieno</td>
          <td style="background-color: rgba(255, 0, 0, 0.4);">Non è prevista
            risposta, il messaggio è per avvertire di un avvenimento </td>
          <td style="background-color: rgba(0, 254, 0, 0.4);">Solo per
            effettuare la simulazione, il client deve sapere quando è stato
            accompagnato alla exitdoor</td>
        </tr>
      </tbody>
    </table>
    <br>
    <br>
    <h3> Test plan</h3>
    <table width="100%">
      <thead>
        <tr>
          <th>Requisito</th>
          <th>Test sullo stato precedente<br>
            come programma prolog</th>
          <th>Test sullo stato successivo<br>
            come programma prolog</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Notify<br>
          </td>
          <td>hall(free). </td>
          <td>hall(busy).<br>
          </td>
        </tr>
        <tr>
          <td>Accept<br>
          </td>
          <td>hall(busy), teatable(N, free, clean). </td>
          <td>hall(busy), teatable(N, reserved(_), clean). </td>
        </tr>
        <tr>
          <td>Inform (non possibile in questo scenario)<br>
          </td>
          <td>hall(busy), findall(N, teatable(N, free, clean), []). </td>
          <td>hall(free), findall(N, teatable(N, free, clean), []). </td>
        </tr>
        <tr>
          <td>Reach<br>
          </td>
          <td>teatable(N, reserved(_), clean),<br>
            hall(busy). </td>
          <td>teatable(N, busy(_), _),<br>
            hall(free). </td>
        </tr>
        <tr>
          <td>Exit<br>
          </td>
          <td>findall(N1, teatable(N1, busy(_), dirty), L1), length(L1,Len1),
            Len1 &gt; 0,<br>
            findall(N2, teatable(N2, free, dirty), L2), length(L2,Len2).<br>
          </td>
          <td>findall(N3, teatable(N3, busy(_), dirty), L3), length(L3,Len3),<br>
            findall(N4, teatable(N4, free, dirty), L4), length(L4,Len4), Len4
            &gt; 0.<br>
            <br>
            (Inoltre Len3==Len1-1 e Len4==Len2+1)</td>
        </tr>
        <tr>
          <td>Clean</td>
          <td> findall(N1, teatable(N1, free, dirty), L1), length(L1,Len1), Len1
            &gt; 0,<br>
            findall(N2, teatable(N2, free, clean), L2), length(L2,Len2). </td>
          <td><br>
            findall(N3, teatable(N3, free, dirty), L3), length(L3,Len3),<br>
            findall(N4, teatable(N4, free, clean), L4), length(L4,Len4), Len4
            &gt; 0.<br>
            <br>
            (Inoltre Len3==Len1-1 e Len4==Len2+1)<br>
          </td>
        </tr>
        <tr>
          <td>Rest</td>
          <td>findall(N1, teatable(N1, free, dirty), L), length(L,Len1), Len1 ==
            0. </td>
          <td>waiter(athome).</td>
        </tr>
      </tbody>
    </table>
    <h2>Test JUnit</h2>
    <pre>package test

import org.junit.Before
import org.junit.After
import org.junit.Test
import org.junit.Assert.assertTrue
import org.junit.Assert.fail
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.delay
import it.unibo.kactor.ActorBasic
import it.unibo.kactor.MqttUtils
import it.unibo.kactor.MsgUtil

class testTearoomRA {
		
	lateinit var waiter    : ActorBasic
	lateinit var smartbell    : ActorBasic
	val mqttTest   	      = MqttUtils("test")
	val initDelayTime     = 4000L   // 
	val useMqttInTest 	  = true
	val mqttbrokerAddr 	  = "localhost"

	fun println(v: Any?){
		System.out.println(v)
	}
	@kotlinx.coroutines.ObsoleteCoroutinesApi
	@kotlinx.coroutines.ExperimentalCoroutinesApi
	@Before
	fun systemSetUp() {
		kotlin.concurrent.thread(start = true) {	 
			it.unibo.ctxwaiter.main()
				if( useMqttInTest ){
					while( ! mqttTest.connectDone() ){
						println( "	attempting MQTT-conn to $mqttbrokerAddr for the test unit ... " )
						Thread.sleep(1000)
						mqttTest.connect("test", mqttbrokerAddr )					 
					}
				}	
		}
		Thread.sleep(3000)
		waiter = it.unibo.kactor.sysUtil.getActor("waiter")!!
		smartbell = it.unibo.kactor.sysUtil.getActor("smartbell")!! 
	}
			
@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi
	@Test
	fun testwaiter(){
	
		testNotify()
		
	    testExit()	
		
		testClean()
		
		testRest()
	
		println("test waiter BYE")
	}
	
@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi
	@After
	fun terminate() {
		println("testTearoom terminated ")
	}
	
@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi
	fun testNotify(){
		println(" --- testNotify ---")
 		runBlocking{
			while(it.unibo.kactor.sysUtil.getAllActorNames().size == 0)
				delay(100)
			assertTrue(waiter.pengine
					.solve("hall(free).")
					.isSuccess())
			
 			MsgUtil.sendMsg(
 				MsgUtil.buildRequest("test","notify", "notify(36)", "smartbell"),
				smartbell)
			
			//notify
 			while(waiter.pengine
					.solve("hall(free).")
					.isSuccess())//the smartbell has not received the request
				delay(50)

			assertTrue(waiter.pengine
					.solve("hall(busy).")//the smartbell has received the request but the waiter has not processed it
					.isSuccess())
			//delay(100)
			
			//accept
			assertTrue(waiter.pengine
					.solve("teatable(_, reserved(_), _).")//the waiter has processed the request but the client is not sitting at the table
					.isSuccess()
			.xor(waiter.pengine
  					.solve("teatable(_, busy(_), _).")//the waiter has processed the request and the client is sitting at the table
					.isSuccess()))
			
			while(waiter.pengine
					.solve("teatable(_, reserved(_), _).")
					.isSuccess())
				delay(50)
			
			//reach
  			assertTrue(waiter.pengine
  					.solve("teatable(_, busy(_), _).")//the waiter has processed the request and the client is sitting at the table
					.isSuccess())
			
			delay(2999)
			println(waiter.geResourceRep())
					
 			
		}
}
	
	
@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi
	fun testExit(){
		println(" --- testExit ---")
		runBlocking{

			val resBeforeExit = waiter.pengine
  					.solve("findall(N1, teatable(N1, busy(_), dirty), L1), length(L1,Len1), Len1 &gt; 0, findall(N2, teatable(N2, free, dirty), L2), length(L2,Len2).")

			
			println("------------------------------------------------------------------------------------------------------------------------")
			println(resBeforeExit)
			println("------------------------------------------------------------------------------------------------------------------------")
			
			
			MsgUtil.sendMsg(
 				MsgUtil.buildDispatch("test","placeorder", "placeorder(1)" ,"waiter"),
				waiter)
					
			//new in sprint2: ASSUMPTION all clients perform all actions in order (i.e. wait for order to be delivered before asking payment)
			while(! waiter.pengine
  					.solve("client(_, consuming).")
					.isSuccess())
			delay(49)
				
 			MsgUtil.sendMsg(
 				MsgUtil.buildDispatch("test","payment", "payment(1)" ,"waiter"),
				waiter)
			
 			while(! waiter.pengine
  					.solve("waiter(exitdoor).")
					.isSuccess())
			delay(49)
			 
			println("--------"+waiter.pengine.solve("roomstate(X).").getSolution())

			
			//ends with waiter at the exitdoor
			val resAfterExit = waiter.pengine
  					.solve("findall(N3, teatable(N3, busy(_), dirty), L3), length(L3,Len3), findall(N4, teatable(N4, free, dirty), L4), length(L4,Len4), Len4 &gt; 0.")
			
			assertTrue(resBeforeExit.getVarValue( "Len1" ).toString().toInt() - 1 == resAfterExit.getVarValue( "Len3" ).toString().toInt())
			assertTrue(resBeforeExit.getVarValue( "Len2" ).toString().toInt() + 1 == resAfterExit.getVarValue( "Len4" ).toString().toInt())
		println(" --- testExit ends---")
		}
}
	
@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi
	fun testClean(){
		println(" --- testClean ---")
		runBlocking{
					
			val resBeforeClean = waiter.pengine
  					.solve("findall(N1, teatable(N1, free, dirty), L1), length(L1,Len1), Len1 &gt; 0, findall(N2, teatable(N2, free, clean), L2), length(L2,Len2).")
			println("--------"+waiter.pengine.solve("roomstate(X).").getSolution())
			println("------------------------------------------------------------------------------------------------------------------------")
			println(resBeforeClean)
			println("------------------------------------------------------------------------------------------------------------------------")

			println("------------------------------------------------------------------------------------------------------------------------")
			println("Cleaning")
			println("------------------------------------------------------------------------------------------------------------------------")
			delay(5000)
				
			val resAfterClean = waiter.pengine
  					.solve("findall(N3, teatable(N3, free, dirty), L3), length(L3,Len3), findall(N4, teatable(N4, free, clean), L4), length(L4,Len4), Len4 &gt; 0.")
			println("--------"+waiter.pengine.solve("roomstate(X).").getSolution())
			println("------------------------------------------------------------------------------------------------------------------------")
			println(resAfterClean)
			println("------------------------------------------------------------------------------------------------------------------------")
			
			assertTrue(resBeforeClean.getVarValue( "Len1" ).toString().toInt() - 1 == resAfterClean.getVarValue( "Len3" ).toString().toInt())
			assertTrue(resBeforeClean.getVarValue( "Len2" ).toString().toInt() + 1 == resAfterClean.getVarValue( "Len4" ).toString().toInt())
		}
	}
	
	@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi
	fun testRest(){
		println(" --- testRest ---")
		runBlocking{
						println("--------"+waiter.pengine.solve("roomstate(X).").getSolution())

			val resBefore = waiter.pengine
  					.solve("findall(N1, teatable(N1, free, dirty), L), length(L,Len1), Len1 == 0.")
						
			assertTrue(resBefore.isSuccess())
//			delay(6000)//some time to get home
			
			//new in sprint2: ASSUMPTION all clients perform all actions in order (i.e. wait for order to be delivered before asking payment)
			while(! waiter.pengine
  					.solve("waiter(athome).")
					.isSuccess())
			delay(49)
						println("--------"+waiter.pengine.solve("roomstate(X).").getSolution())

			val resAfter = waiter.pengine
  					.solve("waiter(athome).")
			
			assertTrue(resAfter.isSuccess())
		}
	}
	


}</pre>
    <h2>Problem analysis</h2>
    <h3> Analisi del modello </h3>
    <div>Per realizzare il sistema, a partire dal modello dei requisiti, sono
      necessari ulteriori componenti che si occupino di
      <ul>
        <li>comandare il robot che realizza il ruolo di Waiter: nel modello, il
          processo di spostamento all'interno della stanza è assente e si giunge
          direttamente al punto finale dal punto iniziale; è necessario un
          componente che sappia comandare fisicamente il Waiter all'interno
          della stanza, portandolo dal punto di partenza in cui si trova a
          quello di arrivo, dettato dallo stato e dalle interazioni: è opportuno
          delegare questo compito ad un componente separato dal waiter per <kc>mantenere
            separato il meccanismo di spostamento</kc> dalla politica di
          gestione dei task;</li>
        <li>mostrare attraverso una interfaccia web lo stato della stanza: al
          momento, l'<kc>infrastruttura qak</kc> espone, tramite protocollo
          CoAP, per ogni attore la <kc>rappresentazione di una risorsa</kc> in
          esso contenuta in formato di stringa; è possibile utilizzare questa
          funzionalità dell'infrastruttura per tenere traccia dello stato di
          tutti gli attori.</li>
      </ul>
      <p><br>
      </p>
      <ul>
      </ul>
      <h4> Modello qak e KB Prolog aggiornati</h4>
      <p> Alla KB sono state aggiunte informazioni sulla posizione e alcune
        clausole per una gestione semplificata. </p>
      <p> Sono stati aggiunti alcuni messaggi per modellare la comunicazione tra
        waiter e robot (componente che si occupa di eseguire lo spostamento
        fisico). </p>
      <p>Ogni movimento fisico del robot che era stato modellato con una attesa
        fittizia nel modello dei requisiti richiede ora l'interazione tra waiter
        e robot, con la richiesta di spostarsi al punto desiderato (che dipende
        da stato e interazioni del waiter): ogni DelayVar nel precedente modello
        diventa quindi una Request da Waiter a Robot e una Reply che fornisce
        l'esito della richiesta.&nbsp; </p>
      <table border="1" width="100%">
        <thead>
          <tr>
            <th>Message name<br>
            </th>
            <th>Dispatch<br>
            </th>
            <th>Request/Reply<br>
            </th>
            <th>Event<br>
            </th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>moveTo</td>
            <td style="background-color: rgba(255, 0, 0, 0.5);"><br>
            </td>
            <td style="background-color: rgba(0, 254, 0, 0.4);">Il waiter delega
              lo spostamento al componente che si occupa di pianificazione e
              movimento (robot)</td>
            <td><br>
            </td>
          </tr>
          <tr>
            <td>moveOk<br>
            </td>
            <td style="background-color: rgba(255, 0, 0, 0.5);"><br>
            </td>
            <td style="background-color: rgba(0, 254, 0, 0.4);">Risposta a
              moveTo se lo spostamento è andato a buon fine, cioè se il waiter
              ora si trova nel posto richiesto<br>
            </td>
            <td><br>
            </td>
          </tr>
          <tr>
            <td>moveKo<br>
            </td>
            <td style="background-color: rgba(255, 0, 0, 0.5);"><br>
            </td>
            <td style="background-color: rgba(0, 254, 0, 0.4);">Risposta a
              moveTo se lo spostamento NON è andato a buon fine, cioè se il
              waiter ora si trova in un posto diverso da quello richiesto</td>
            <td><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      <table padding="0px" border="0px">
        <tbody>
          <tr valign="top">
            <!-- Modello -->
            <td>
              <pre>System tearoom
mqttBroker "localhost" : 1883 eventTopic "unibo/gozzi/events"

//Client - Smartbell, Entering
Request notify : notify(TEMP)
Reply deny : deny(X)
Reply accept : accept(CID)
Reply full : full(CID, WTIME)

//Smartbell - Waiter, Free Table
Request table : table(CID)
Reply available : available(CID)
Reply full : full(CID, WTIME)
Dispatch clientatentrance : clientatentrance(Cid) // self message

//Client - Waiter - Barman, Requesting+serving tea
Dispatch placeorder : placeorder(CID)
Request relayorder : relayorder(Cid)
Reply orderready : orderready(Cid)
//---------------------------------------------------------
Event delivered : delivered($Cid) 	// for client simulation purpose
//---------------------------------------------------------

//Client - Waiter, Requesting payment
Dispatch payment : payment(Cid)
//---------------------------------------------------------
Event paymentOk : paymentOk(Cid)	// for client simulation purpose
Event exitOk : exitOk(Cid)			// for client simulation purpose
//---------------------------------------------------------

//Waiter - robot, movement
Request moveTo : moveTo(OldX, OldY, X, Y)	//start pos + destination pos
Reply moveOk : moveOk(X,Y)		//reached destination pos
Reply moveKo : moveKo(X,Y)	 	//current pos != moveTo

Context ctxwaiter ip [host="localhost" port=8050]  			+mqtt
Context ctxsmartbell ip [host="localhost" port=8051]		+mqtt
//Context ctxhall ip [host="localhost" port=8052]			+mqtt
Context ctxbarman ip [host="localhost" port=8056]			+mqtt


//implements planner + actuator
QActor robot context ctxwaiter{
	State s0 initial{
		println("robot init")
	}
	Transition t0
	whenRequest moveTo -&gt; move
	
	State move{
		//println("robot move")
		//printCurrentMessage
		onMsg(moveTo : moveTo(A,B,X,Y)){
			[#
				val X = payloadArg(2)
				val Y = payloadArg(3)
				#]
			replyTo moveTo with moveOk : moveOk($X, $Y)
		}
	}
	Transition t0
	whenRequest moveTo -&gt; move
}

//ExternalQActor barman context ctxbarman
QActor barman context ctxbarman{
	
	State s0 initial{
	}
	Transition t0
		whenRequest relayorder -&gt; prepareTea
	
	State prepareTea{
		onMsg( relayorder : relayorder(Cid) ){
			[# val Cid = payloadArg(0) #]
			delay 1000 // time to prepare tea
			replyTo relayorder with orderready : orderready($Cid)
			updateResource [# "tea prepared for $Cid" #]
		}
	}
	Transition t0
		whenRequest relayorder -&gt; prepareTea
}

QActor smartbell context ctxsmartbell{
	
	[# 
		val MaxTemp = 37.5 
		var Cid = 1
	#]
	
	State s0 initial{
	}
	Transition t0
		whenRequest notify -&gt; checkTemp
		
	State checkTemp{
		onMsg(notify : notify(Temp)){
			if [# payloadArg(0).toDouble() &lt; MaxTemp #] {
				request waiter -m table : table($Cid) // case (a)
			}
			else{
				replyTo notify with deny : deny(0) //case (b)
			}
		}
	}
	Transition t1
		whenRequest 	notify 		-&gt; checkTemp 	//in case (b)
		whenReply 		available 	-&gt; replyClient 	//in case (a)
		whenReply 		full 		-&gt; replyClient 	//in case (a)
		
	State replyClient{
		onMsg(available : available(CID)){
			replyTo notify with accept : accept($Cid)
		}
		onMsg(full : full(CID,WTIME)){
			[# val WaitTime = payloadArg(0) #]
			replyTo notify with full : full($Cid, $WaitTime)
		}
		[# Cid++ #] //new CID for next Client
	}
	Transition t2
		whenRequest notify -&gt; checkTemp
}


QActor waiter context ctxwaiter {
	
	[#
		val MaxStayTime 	= 100000L	
		val DelayTime 		= 1000L
		val RestWaitTime 	= 5000L
		var CurrentCid		= ""
	#]
	
	State s0 initial{
		println("waiter starting")
		discardMsg Off
		solve( consult("tearoomKB-PA-sprint1.pl") )
		
		solve( roomstate(S) ) 
		ifSolved { //Documentation says: #S =&gt; ${getCurSol("S").toString()}
			updateResource[# getCurSol("S").toString() #]
		}
	}
	Transition t0
		whenRequest table -&gt; checkTableAvail
	
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//this state implements requirements "accept" and "inform"
	State checkTableAvail{
		println("waiter checkTableAvail")
		onMsg(table : table(Cid)){
			[# CurrentCid = payloadArg(0) #]
			solve(updateWaiterState(X,checkAvailability($CurrentCid)))
			solve( occupyHall($CurrentCid) )
			solve( reserveTable(Num, $CurrentCid) )//accept
			ifSolved {
				replyTo table with available : available($CurrentCid)
				forward waiter -m clientatentrance : clientatentrance($CurrentCid) //so that the waiter will eventually do the "reach" task
			}
			else{//inform
				replyTo table with full : full($CurrentCid, $MaxStayTime)
				solve( freeHall($CurrentCid) )
			}
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
	}
	Transition t0
		whenMsg clientatentrance -&gt; reach
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//this state implements requirement "reach"
	State reach{//goto entrance + goto table
		println("waiter reach")
		onMsg(clientatentrance : clientatentrance(CurrentCid)){
			[# CurrentCid = payloadArg(0) #]
			solve(updateWaiterState(X,reach($CurrentCid)))
		}
		onMsg(moveKo : moveKo(X, Y)){//in case the move failed update where the robot has arrived
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(A,$X,$Y))
		}
		//solve(pos(entrancedoor, X, Y)) 
		//----------------------------------------------------------------------------------------------------
		//request robot -m moveTo : moveTo(#X, #Y) //-------------------- no implementation for #VarRefInStr ?
		//----------------------------------------------------------------------------------------------------
		solve(coordinatesTo(entrancedoor, OldX, OldY, X, Y))//move to entrancedoor
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString()		#]
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
	}
	Transition t0
		whenReply moveOk -&gt; reachp2//now at the entrancedoor
		whenReply moveKo -&gt; reach  //retry
	
	
	State reachp2{//at entrance + goto table
		println("waiter reachp2")
		onMsg(moveKo : moveKo(X, Y)){//in case the move failed update where the robot has arrived
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(_,$X,$Y))
		}
		onMsg(moveOk : moveOk(X,Y)){
			solve( freeHall($CurrentCid) )//client "collected"
			solve( updateWaiterLoc(entrancedoor,X,Y) )
			solve( updateWaiterState(X,at(entrancedoor)) )
		}
		solve( teatable(Num, reserved($CurrentCid), clean) ) // find reserved table
		[# val TableNum = getCurSol("Num").toString() #]
		
		solve(coordinatesTo(teatable($TableNum), OldX, OldY, X, Y))//move to teatable
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString()		#]
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
	}
	Transition t0
		whenReply moveOk -&gt; reachp3	 //now at the table
		whenReply moveKo -&gt; reachp2  //retry
	
	State reachp3{//at table
		println("waiter reachp3")
		solve( teatable(Num, reserved($CurrentCid), clean) ) // find reserved table
		[# val TableNum = getCurSol("Num").toString() #]
		solve( updateWaiterState(X, deployed($CurrentCid,$TableNum)) )
		solve( updateWaiterLoc(teatable($TableNum),X,Y))
		solve( engageTable($TableNum, $CurrentCid) ) // occupy table
		solve( roomstate(S) ) ifSolved { updateResource[# getCurSol("S").toString() #] }
	}
	Transition t0
		whenMsg placeorder -&gt; takeOrder
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//this state implements requirement "take"
	State takeOrder{//goto table + request relayorder
		println("waiter takeOrder")
		onMsg(moveKo : moveKo(X, Y)){//in case the move failed update where the robot has arrived
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(S,$X,$Y))
		}
		onMsg(placeorder : placeorder(CurrentCid)){
			[# CurrentCid = payloadArg(0) #]
			solve(updateWaiterState(X, goTakeOrder($CurrentCid)))
			}
		solve( teatable(Num, busy($CurrentCid), dirty) ) // find correct table
		[# val TableNum = getCurSol("Num").toString() #]
		solve(coordinatesTo(teatable($TableNum), OldX, OldY, X, Y))//move to teatable
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString()		#]
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
	}
	Transition t0
		whenReply moveOk -&gt; takeOrderp2	 //now at the table
		whenReply moveKo -&gt; takeOrder  //retry
		
		
		
	State takeOrderp2{//at table + request relayorder
		solve( teatable(Num, busy($CurrentCid), dirty) ) // find correct table
		[# val TableNum = getCurSol("Num").toString() #]
		solve( updateWaiterLoc(teatable($TableNum),X,Y))
		solve( updateWaiterState(X, takingOrder($CurrentCid)) )
		request barman -m relayorder : relayorder($CurrentCid) //real task BL
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
	}
	Transition t0
		whenReply orderready -&gt; serveOrder
		
		
		
		

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//this state implements requirement "serve"
	State serveOrder{//goto bar + goto table
		println("waiter serveOrder")
		onMsg(orderready : orderready(CurrentCid)){
			[# CurrentCid = payloadArg(0) #]
			solve(updateWaiterState(X, getOrder($CurrentCid)))
		}
		onMsg(moveKo : moveKo(X, Y)){//in case the move failed update where the robot has arrived
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(S,$X,$Y))
		}
		solve(coordinatesTo(barman, OldX, OldY, X, Y))//move to barman
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString()	#]		
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
	}
	Transition t0
		whenReply moveOk -&gt; serveOrderp2	 //now at the table
		whenReply moveKo -&gt; serveOrder  //retry
		
		
	State serveOrderp2{//at bar, goto table
		onMsg(moveKo : moveKo(X, Y)){//in case the move failed update where the robot has arrived
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(_,$X,$Y))
		}
		onMsg(moveOk : moveOk(X,Y)){
			solve( updateWaiterState(X, bar($CurrentCid)) )
			solve( updateWaiterLoc(barman,X,Y) )
		}
		solve( teatable(Num, busy($CurrentCid), dirty) ) // find correct table
		[# val TableNum = getCurSol("Num").toString() #]
		solve(coordinatesTo(teatable($TableNum), OldX, OldY, X, Y))//move to teatable
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString() #]
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}		
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}	
	}
	Transition t0
		whenReply moveOk -&gt; serveOrderp3	 //now at the table
		whenReply moveKo -&gt; serveOrderp2  //retry
		
	State serveOrderp3{//at table
		onMsg(moveOk : moveOk(X,Y)){
			solve( teatable(Num, busy($CurrentCid), dirty) ) // find correct table
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   
				val TableNum = getCurSol("Num").toString()	#]
			solve( updateWaiterLoc(teatable($TableNum),$X,$Y) )
			solve( updateWaiterState(X, serving($CurrentCid)) )
			//-------------------------------------------
			emit delivered : delivered($CurrentCid) //just for simulation, in real life the client would see that the waiter has brought the tea
			//-------------------------------------------
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
	}
	Transition t0
		whenMsg payment -&gt; getPayment
		
		
		
		
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//this state implements requirements "collect" and "exit"
	State getPayment{//goto table + goto exitdoor
		println("waiter getPayment")
		onMsg(payment : payment(CurrentCid)){
			[# CurrentCid = payloadArg(0) #]
			solve(updateWaiterState(X, getPayment($CurrentCid)))
		}
		onMsg(moveKo : moveKo(X, Y)){//in case the move failed update where the robot has arrived
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(_,$X,$Y))
		}
		solve( teatable(Num, busy($CurrentCid), dirty) ) // find correct table
		[# val TableNum = getCurSol("Num").toString() #]
		solve(coordinatesTo(teatable($TableNum), OldX, OldY, X, Y))//move to teatable
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString()		#]
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
	}
	Transition t0
		whenReply moveOk -&gt; getPaymentp2	 //now at the table
		whenReply moveKo -&gt; getPayment  //retry
		
	State getPaymentp2{//at table + goto exitdoor
		onMsg(moveOk : moveOk(X,Y)){
			emit paymentOk : paymentOk($CurrentCid)
			solve( teatable(Num, busy($CurrentCid), dirty) ) // find correct table
			[# val TableNum = getCurSol("Num").toString() #]
			solve( updateWaiterState(X, paymentatteatable($TableNum)) ) 
			solve( freeTable($TableNum, $CurrentCid) )
		}
		onMsg(moveKo : moveKo(X, Y)){//in case the move failed update where the robot has arrived
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(_,$X,$Y))
		}
		
		solve(coordinatesTo(exitdoor, OldX, OldY, X, Y))//move to exitdoor
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString()		#]
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
	}
	Transition t0
		whenReply moveOk -&gt; escortToExit	 //goto exitdoor
		whenReply moveKo -&gt; getPaymentp2  //retry
		
	State escortToExit{//at exitdoor
		onMsg(moveOk : moveOk(X,Y)){
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			emit exitOk : exitOk($CurrentCid)
			solve( updateWaiterLoc(at(exitdoor),$X,$Y) )
			solve( updateWaiterState(X, at(exitdoor)) ) 
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
		delay 300
	}
	Goto cleanTable
	
	
	
//----------------------------------------------------------------------------------------------------
	State cleanTable{
		println("waiter cleanTable")
		solve( dirtyTable(Num) )
		[# val TableNum = getCurSol("Num").toString() #]
		solve( updateWaiterState(X, gocleanteatable($TableNum)) ) 
		solve(coordinatesTo(teatable($TableNum), OldX, OldY, X, Y))//move to teatable
		//[#println(currentSolution)#]
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString()		#]
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
		}
	Transition t0
		whenReply moveOk -&gt; doClean	 //now at the table
		whenReply moveKo -&gt; cleanTable  //retry
		
	State doClean{
		onMsg(moveOk : moveOk(X, Y)){
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(teatable(Num),$X,$Y))
			[# val TableNum = getCurSol("Num").toString() #]
			solve(updateWaiterState(X, cleaning($TableNum)))
		
			delayVar DelayTime // clean table, waiter cannot process incoming messages
			solve( cleanTable($TableNum) )
			solve( roomstate(S) ) ifSolved { updateResource[# getCurSol("S").toString() #] }

		}
	}
	Transition t0
		whenTimeVar RestWaitTime -&gt; rest
		whenRequest table -&gt; checkTableAvail
		
		
		
		
//----------------------------------------------------------------------------------------------------		
	State rest{
		println("waiter rest")
		onMsg(moveKo : moveKo(X, Y)){//in case the move failed update where the robot has arrived
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(_,$X,$Y))
			solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
		}
		solve(coordinatesTo(home, OldX, OldY, X, Y))//move to teatable
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString()		#]
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}
		}
	Transition t0
		whenReply moveOk -&gt; atHome	 //now at the table
		whenReply moveKo -&gt; rest  //retry
		
	State atHome{
		println("waiter athome")
		solve( updateWaiterState(X, rest ) )
		solve( updateWaiterLoc(home,X,Y) )
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
	}
	Transition t0
		whenRequest table -&gt; checkTableAvail
	
}

</pre> </td>
            <!-- KB -->
            <td>
              <pre> %===========================================
% tearoomkb.pl
%===========================================

%% ------------------------------------------ 
%% Positions
%% ------------------------------------------ 

pos( home, 0, 0 ).
pos( entrancedoor, 4, 1 ).
pos( exitdoor, 4, 6 ).
pos( barman, 0, 5 ).
pos( teatable(1), 2, 3 ).
pos( teatable(2), 2, 5 ).
 
%% ------------------------------------------ 
%% Teatables
%% teatable(Num, {free, reserved(Cid), busy(Cid)}, {clean, dirty}).
%% ------------------------------------------ 
teatable( 1, free, clean ).
teatable( 2, free, clean ). 

tableavailable(N):- teatable(N,	free, clean ).

numavailabletables(N) :-
	findall( N, teatable( N, free, clean ), NList),
	length( NList, N ).

reserveTable(N,Cid)	 :-
	retract( teatable( N, free, clean ) ) ,
	!,
	assert( teatable( N, reserved(Cid), clean ) ).
	
reserveTable(_,_).	

%%reservedTable(N, Cid, Clean) :- teatable( N, reserved(Cid), Clean ). %%tavolo prenotato da Cid

engageTable(N,Cid)	 :-
	retract( teatable( N, reserved(Cid), clean ) ) ,
	!,
	assert( teatable( N, busy(Cid), dirty ) ).

freeTable(N, Cid) :-
	retract( teatable( N, busy(Cid), dirty ) ),
	!,
	assert( teatable( N, free, dirty ) ).
freeTable(_,_).	
	
dirtyTable(Num) :- teatable(Num, free, dirty).	
	
cleanTable(N)	 :-
	%% stdout &lt;- println( tearoomkb_cleanTable(N) ),
	retract( teatable( N, free, dirty ) ) ,
	!,
	asserta( teatable( N, free, clean ) ).
cleanTable(N).	
 
stateOfTeatable( [teatable1(V1,V2)] ) :-
	teatable( 1, V1, V2 ).
	
stateOfTeatables( [teatable(1, V1, V2),teatable(2, V3, V4)] ) :-
	teatable( 1, V1, V2 ),
	teatable( 2, V3, V4 ).

%% ------------------------------------------ 
%% Waiter
%% ------------------------------------------ 

waiter( rest, 0, 0 ).	

%%update textual state, keep map location
updateWaiterState(Old,New) :- 
	retract(waiter(Old, X, Y)),
	!,
	assert(waiter(New, X, Y)).

%%keep textual state, update map location (either give PositionName or coordinates of it)
updateWaiterLoc(PositionName, NewX, NewY) :- 
	pos(PositionName, NewX, NewY),
	!,
	retract(waiter(State, _, _)),
	!,
	assert(waiter(State, NewX, NewY)).

%%keep textual state, update map location to any location
updateWaiterLoc(PositionName, NewX, NewY) :- 
	retract(waiter(State, _, _)),
	!,
	assert(waiter(State, NewX, NewY)).
	
%%update textual state w/ position name, update map location to the position location
updateWaiterLoc(PositionName) :- 
	pos(PositionName, X, Y),
	!,
	retract(waiter(_, _, _)),
	!,
	assert(waiter(PositionName, X, Y)).
	
%%get both waiter and destination coordinates from destination name
coordinatesTo(PositionName, WX, WY, X, Y) :-
	waiter(_, WX, WY),
	pos(PositionName, X, Y).
%% ------------------------------------------ 
%% Hall
%% ------------------------------------------ 
hall(free).

freeHall(X) :- 
retract(hall(free)),
!,
assert(hall(busy)).

occupyHall(X) :- 
retract(hall(busy)),
!,
assert(hall(free)).


%% ------------------------------------------ 
%% Room as a whole
%% ------------------------------------------ 
roomstate(  state( waiter(S,X,Y), tables(V) )  ):-
	 waiter(S,X,Y), stateOfTeatables(V) .
	 
	

</pre> </td>
          </tr>
        </tbody>
      </table>
      <ul>
      </ul>
    </div>
    <h3> Sample room states from one client interaction </h3>
    <pre style="font-size:90%">state(waiter(rest,0,0),tables([teatable(1,free,clean),teatable(2,free,clean)]))
state(waiter(checkAvailability(1),0,0),tables([teatable(1,reserved(1),clean),teatable(2,free,clean)]))
state(waiter(reach(1),0,0),tables([teatable(1,reserved(1),clean),teatable(2,free,clean)]))
state(waiter(at(entrancedoor),4,1),tables([teatable(1,reserved(1),clean),teatable(2,free,clean)]))
state(waiter(deployed(1,1),2,3),tables([teatable(1,busy(1),dirty),teatable(2,free,clean)]))
state(waiter(goTakeOrder(1),2,3),tables([teatable(1,busy(1),dirty),teatable(2,free,clean)]))
state(waiter(takingOrder(1),2,3),tables([teatable(1,busy(1),dirty),teatable(2,free,clean)]))
state(waiter(getOrder(1),2,3),tables([teatable(1,busy(1),dirty),teatable(2,free,clean)]))
state(waiter(bar(1),0,5),tables([teatable(1,busy(1),dirty),teatable(2,free,clean)]))
state(waiter(serving(1),2,3),tables([teatable(1,busy(1),dirty),teatable(2,free,clean)]))
state(waiter(getPayment(1),2,3),tables([teatable(1,busy(1),dirty),teatable(2,free,clean)]))
state(waiter(paymentatteatable(1),2,3),tables([teatable(1,free,dirty),teatable(2,free,clean)]))
state(waiter(at(exitdoor),4,6),tables([teatable(1,free,dirty),teatable(2,free,clean)]))
state(waiter(gocleanteatable(1),4,6),tables([teatable(1,free,dirty),teatable(2,free,clean)]))
state(waiter(cleaning(1),2,3),tables([teatable(1,free,clean),teatable(2,free,clean)]))
state(waiter(rest,0,0),tables([teatable(1,free,clean),teatable(2,free,clean)]))</pre>
    <h2>Project</h2>
    <h3> Waiter </h3>
    <p> Dall'analisi del problema risulta opportuno decomporre in più parti il
      sottosistema Waiter, esattamente tre seguendo il principio di Singola
      Responsabilità: </p>
    <ul>
      <li> Waiter: è quell'attore che si occupa della politica (cioè elaborare i
        task dal punto di vista logico) e che gestisce lo stato della stanza;</li>
      <li> Robot: è quell'attore a cui il Waiter demanda lo spostamento fisico;
        come evidenziato in analisi del problema, il meccanismo è implementabile
        mediante un <kc>algoritmo di planning-scheduling</kc>, in cui, date
        posizioni iniziale e finale, si ottiene una serie di azioni per
        raggiungere il goal; in questo modo, risulta semplice, a livello di
        modello, trovare la sequenza di mosse da percorrere per arrivare alla
        destinazione goal; <a href="http://htmlpreview.github.io/?https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.planner20/userDocs/LabPlanner.html">come
          visto a lezione</a> è disponibile un componente software che
        implementa tale algoritmo: la definizione formale è data dal file <a href="https://github.com/anatali/iss2020LabBo/blob/master/unibolibs/it.unibo.planner20-1.0.jar"
          target="code"><span style="color: black;"></span>it.unibo.planner20-1.0.jar</a>.<br>
        L'attore Robot NON si occupa direttamente dello spostamento fisico del
        ddr waiter ma sfrutta un altro attore (basicrobot);</li>
      <li>Basicrobot: attore che si occupa di ricevere messaggi applicativi di
        movimento elementari e tradurli in movimenti fisici per vari tipi di
        robot reali e virtuali; formalmente definito nel progetto <a href="https://github.com/anatali/iss2020LabBo/tree/master/it.unibo.qak20.basicrobot">basicrobot</a>;
        permette di separare due meccanismi che sono effettivamente indipendenti
        (planning ed esecuzione).</li>
    </ul>
    <p>Per la comunicazione Robot - basicrobot sono stati introdotti alcuni
      messaggi nel modello:</p>
    <table border="1" width="100%">
      <thead>
        <tr>
          <th class="equalfour">Message name<br>
          </th>
          <th class="equalfour">Dispatch<br>
          </th>
          <th class="equalfour">Request/Reply<br>
          </th>
          <th class="equalfour">Event<br>
          </th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>doMove</td>
          <td style="background-color: rgba(0, 255, 0, 0.4);"> Automessaggio in
            caso vi siano azioni elementari di spostamento da effettuare,
            altrimenti piano completato<br>
          </td>
          <td style="background-color: rgba(255, 255, 255, 0.4);"><br>
          </td>
          <td style="background-color: rgba(255, 0, 0, 0.4);">Il messaggio non
            deve essere perso<br>
          </td>
        </tr>
        <tr>
          <td>step</td>
          <td style="background-color: rgba(255, 255, 255, 0.4);"><br>
          </td>
          <td style="background-color: rgba(0, 254, 0, 0.4);">Comunicazione
            standard con il basicrobot</td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>stepDone<br>
          </td>
          <td style="background-color: rgba(255, 255, 255, 0.4);"><br>
          </td>
          <td style="background-color: rgba(0, 254, 0, 0.4);">Comunicazione
            standard con il basicrobot </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>stepFail<br>
          </td>
          <td style="background-color: rgba(255, 255, 255, 0.4);"><br>
          </td>
          <td style="background-color: rgba(0, 254, 0, 0.4);">Comunicazione
            standard con il basicrobot</td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>cmd<br>
          </td>
          <td style="background-color: rgba(0, 255, 0, 0.4);">Comunicazione
            standard con il basicrobot </td>
          <td style="background-color: rgba(255, 255, 255, 0.4);"><br>
          </td>
          <td><br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <hr>
    <div> Alla KB sono stati aggiunti alcuni fatti per la configurazione del
      sistema (debug e tempi di attesa). </div>
    <hr> <br>
    <table padding="0px" border="0px">
      <tbody>
        <tr valign="top">
          <!-- Modello -->
          <td>
            <pre> System tearoom
mqttBroker "localhost" : 1883 eventTopic "unibo/gozzi/events"

//Client - Smartbell, Entering
Request notify : notify(TEMP)
Reply deny : deny(X)
Reply accept : accept(CID)
Reply full : full(CID, WTIME)

//Smartbell - Waiter, Free Table
Request table : table(CID)
Reply available : available(CID)
Reply full : full(CID, WTIME)
Dispatch clientatentrance : clientatentrance(Cid) // self message

//Client - Waiter - Barman, Requesting+serving tea
Dispatch placeorder : placeorder(CID)
Request relayorder : relayorder(Cid)
Reply orderready : orderready(Cid)
//---------------------------------------------------------
Event delivered : delivered($Cid) 	// for client simulation purpose
//---------------------------------------------------------

//Client - Waiter, Requesting payment
Dispatch payment : payment(Cid)
//---------------------------------------------------------
Event attable: attable(Cid)			// for client simulation purpose
Event paymentOk : paymentOk(Cid)	// for client simulation purpose
Event exitOk : exitOk(Cid)			// for client simulation purpose
//---------------------------------------------------------

//Waiter - robot, movement
Request moveTo : moveTo(OldX, OldY, X, Y)	//start pos + destination pos
Reply moveOk : moveOk(X,Y)		//reached destination pos
Reply moveKo : moveKo(X,Y)	 	//current pos != moveTo

//Robot - basicrobot
Dispatch doMove : doMove(M)
Request step       : step( TIME )	
Reply   stepdone   : stepdone(V)  
Reply   stepfail   : stepfail(DURATION, CAUSE)
Dispatch cmd       : cmd(MOVE)  

Context ctxwaiter ip [host="localhost" port=8050]  			+mqtt
Context ctxsmartbell ip [host="localhost" port=8051]		+mqtt
//Context ctxhall ip [host="localhost" port=8052]			+mqtt
Context ctxbarman ip [host="localhost" port=8056]			+mqtt
Context ctxbasicrobot ip [host="127.0.0.1" port=8020] 		+mqtt


//implements planner
QActor robot context ctxwaiter{
	
	[# 
		var CurrentPlannedMove = ""
		val mapname                    = "teaRoomExplored"
		var planInterrupted            = false
//		val StepTime                   = 600L //firefox f11 on laptop registrazione
//		val StepTime                   = 800L //firefox f11 on monitor registrazione
//		val StepTime                   = 600L //firefox f11 on monitor no registrazione
		var X = ""
		var Y = ""
		var Debug = false
		var StepTime = 600L
		var StepFailWaitTime = 10000L
	#]	 

	State s0 initial{
		solve( consult("tearoomKB_Proj.pl") )
		solve( stepTime(X) ) 			ifSolved { [# StepTime = getCurSol("X").toString().toLong() #]}
		solve( stepFailWaitTime(X) )	ifSolved { [# StepFailWaitTime = getCurSol("X").toString().toLong() #]}
		solve( debug(X) ) 				ifSolved { [# Debug = true #]}
		println("robot init")
		run itunibo.planner.plannerUtil.initAI()
		run itunibo.planner.plannerUtil.loadRoomMap( mapname )
		[#if(Debug)#]println("INITIAL MAP") 
 		[#if(Debug)#]run itunibo.planner.plannerUtil.showMap() 
	}
	Transition t0
	whenRequest moveTo -&gt; planForMoves
	
	State planForMoves{
		[#if(Debug)#]println("robot planForMoves")
		onMsg(moveTo : moveTo(A,B,X,Y)){
			[#
				val A = payloadArg(0)
				val B = payloadArg(1)
				X = payloadArg(2)
				Y = payloadArg(3)
				itunibo.planner.plannerUtil.planForGoal(X,Y)
				if(Debug){
					println("Invio per iniziare da $A $B a goal $X $Y")
					println("Le mosse sono ${itunibo.planner.plannerUtil.getActions()}")
					readLine()
				}
				delay(500)
			#]
		}
	}
	Goto execPlannedMoves
 
	State execPlannedMoves{ //list of moves to do
		println("robot execPlannedMoves")
		onMsg(stepdone : stepdone(A)){
			if [# Debug #] {[#
				val msg = "robot: stepdone $CurrentPlannedMove : ${payloadArg(0)}"
				itunibo.planner.plannerUtil.showMap() 
				itunibo.planner.plannerUtil.updateMap(CurrentPlannedMove,msg)#]
				}
    		else{
    			run	itunibo.planner.plannerUtil.updateMap(CurrentPlannedMove,"")
    		}
    	}
 		[#  
 			CurrentPlannedMove = itunibo.planner.plannerUtil.getNextPlannedMove()
 			if(Debug){
	 			println("Invio per vedere mosse rimanenti")
				readLine()
				itunibo.planner.plannerUtil.showMap() 
				println("Now $CurrentPlannedMove in ${itunibo.planner.plannerUtil.getActions()}")
			}
		#]
 		if [# CurrentPlannedMove.length &gt; 0 # ]{
 			forward robot -m doMove : doMove($CurrentPlannedMove)
 		}
 		else{//	no moves left to do, arrived at the goal
 			replyTo moveTo with moveOk : moveOk($X, $Y)
 		}
 	}
 	Transition t0 	
 			whenRequest moveTo and [# CurrentPlannedMove.length == 0 #] -&gt; planForMoves
 			whenMsg doMove  -&gt; execTheMove
   	 	  			   
  	State execTheMove{ // do one of the moves at a time, either step or 90degree turn
		[#if(Debug)#]println("robot execTheMove")
		delay 100
  		onMsg( doMove : doMove(w) ){ 	// o la mossa è w o l/r	
				request basicrobot -m step : step($StepTime)
			}
		else{
				forward basicrobot -m cmd : cmd($CurrentPlannedMove)
				[#if(Debug)#]run itunibo.planner.plannerUtil.updateMap(CurrentPlannedMove,"robot: turning $CurrentPlannedMove")
				[#else#]run itunibo.planner.plannerUtil.updateMap(CurrentPlannedMove,"")
				delay 300
			}
  	} 
    Goto execPlannedMoves if [# CurrentPlannedMove != "w" #] else waitReply
    
    State waitReply{
		[#if(Debug)#]println("robot waitReply")
    }
    Transition t0
    	whenReply stepdone -&gt; execPlannedMoves
    	whenReply stepfail -&gt; replyWithFailure
    
    State replyWithFailure{
		println("robot replyWithFailure")
    	[#
    		val NewX = itunibo.planner.plannerUtil.get_curPos().first
    		val NewY = itunibo.planner.plannerUtil.get_curPos().second
    		itunibo.planner.plannerUtil.showMap() 
    		println("Move Robot manually to the r cell within $StepFailWaitTime seconds, then press Enter if Debug")
    		if(Debug) 	readLine()
	    	else 		delay(StepFailWaitTime)
    	#]
    	replyTo moveTo with moveKo : moveKo($NewX, $NewY)
    }
    Transition t0
		whenRequest moveTo -&gt; planForMoves

}


//implements actuator
ExternalQActor basicrobot context ctxbasicrobot

//ExternalQActor barman context ctxbarman
QActor barman context ctxbarman{
	
	State s0 initial{
	}
	Transition t0
		whenRequest relayorder -&gt; prepareTea
	
	State prepareTea{
		onMsg( relayorder : relayorder(Cid) ){
			[# val Cid = payloadArg(0) #]
			delay 1000 // time to prepare tea
			replyTo relayorder with orderready : orderready($Cid)
			updateResource [# "tea prepared for $Cid" #]
		}
	}
	Transition t0
		whenRequest relayorder -&gt; prepareTea
}

QActor smartbell context ctxsmartbell{
	
	[# 
		val MaxTemp = 37.5 
		var Cid = 1
	#]
	
	State s0 initial{
	}
	Transition t0
		whenRequest notify -&gt; checkTemp
		
	State checkTemp{
		onMsg(notify : notify(Temp)){
			if [# payloadArg(0).toDouble() &lt; MaxTemp #] {
				request waiter -m table : table($Cid) // case (a)
			}
			else{
				replyTo notify with deny : deny(0) //case (b)
			}
		}
	}
	Transition t1
		whenRequest 	notify 		-&gt; checkTemp 	//in case (b)
		whenReply 		available 	-&gt; replyClient 	//in case (a)
		whenReply 		full 		-&gt; replyClient 	//in case (a)
		
	State replyClient{
		onMsg(available : available(CID)){
			replyTo notify with accept : accept($Cid)
		}
		onMsg(full : full(CID,WTIME)){
			[# val WaitTime = payloadArg(0) #]
			replyTo notify with full : full($Cid, $WaitTime)
		}
		[# Cid++ #] //new CID for next Client
	}
	Transition t2
		whenRequest notify -&gt; checkTemp
}


QActor waiter context ctxwaiter {
	
	[#
		val MaxStayTime 	= 100000L	
		val DelayTime 		= 1000L
		val RestWaitTime 	= 5000L
		var CurrentCid		= ""
		var Debug = false
	#]
	
	State s0 initial{
		println("project waiter starting")
		discardMsg Off
		solve( consult("tearoomKB_Proj.pl") )
		solve( debugwaiter(X) ) 				ifSolved { [# Debug = true #]}

		solve( roomstate(S) ) 
		ifSolved { //Documentation says: #S =&gt; ${getCurSol("S").toString()}
			updateResource[# getCurSol("S").toString() #]
			[#if(Debug)#]println("waiter coap updated")
		}
	}
	Transition t0
		whenRequest table -&gt; checkTableAvail
	
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//this state implements requirements "accept" and "inform"
	State checkTableAvail{
		println("waiter checkTableAvail")
		onMsg(table : table(Cid)){
			[# CurrentCid = payloadArg(0) #]
			solve(updateWaiterState(X,checkAvailability($CurrentCid)))
			solve( occupyHall($CurrentCid) )
			solve( reserveTable(Num, $CurrentCid) )//accept
			ifSolved {
				replyTo table with available : available($CurrentCid)
				forward waiter -m clientatentrance : clientatentrance($CurrentCid) //so that the waiter will eventually do the "reach" task
			}
			else{//inform
				replyTo table with full : full($CurrentCid, $MaxStayTime)
				solve( freeHall($CurrentCid) )
			}
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #] [#if(Debug) println("waiter coap updated\n${geResourceRep()}")#] }
	}
	Transition t0
		whenMsg clientatentrance -&gt; reach
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//this state implements requirement "reach"
	State reach{//goto entrance + goto table
		println("waiter reach")
		onMsg(clientatentrance : clientatentrance(CurrentCid)){
			[# CurrentCid = payloadArg(0) #]
			solve(updateWaiterState(X,reach($CurrentCid)))
		}
		onMsg(moveKo : moveKo(X, Y)){//in case the move failed update where the robot has arrived
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(A,$X,$Y))
		}
		//solve(pos(entrancedoor, X, Y)) 
		//----------------------------------------------------------------------------------------------------
		//request robot -m moveTo : moveTo(#X, #Y) //-------------------- no implementation for #VarRefInStr ?
		//----------------------------------------------------------------------------------------------------
		solve(coordinatesTo(entrancedoor, OldX, OldY, X, Y))//move to entrancedoor
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString()		#]
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	 [#if(Debug) println("waiter coap updated\n${geResourceRep()}")#] }
	}
	Transition t0
		whenReply moveOk -&gt; reachp2//now at the entrancedoor
		whenReply moveKo -&gt; reach  //retry
	
	State reachp2{//at entrance + goto table
		println("waiter reachp2")
		onMsg(moveKo : moveKo(X, Y)){//in case the move failed update where the robot has arrived
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(_,$X,$Y))
		}
		onMsg(moveOk : moveOk(X,Y)){
			solve( freeHall($CurrentCid) )//client "collected"
			solve( updateWaiterLoc(entrancedoor,X,Y) )
			solve( updateWaiterState(X,at(entrancedoor)) )
		}
		solve( teatable(Num, reserved($CurrentCid), clean) ) // find reserved table
		[# val TableNum = getCurSol("Num").toString() #]
		
		solve(coordinatesTo(teatable($TableNum), OldX, OldY, X, Y))//move to teatable
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString()		#]
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
	}
	Transition t0
		whenReply moveOk -&gt; reachp3	 //now at the table
		whenReply moveKo -&gt; reachp2  //retry
	
	State reachp3{//at table
		println("waiter reachp3")
		solve( teatable(Num, reserved($CurrentCid), clean) ) // find reserved table
		[# val TableNum = getCurSol("Num").toString() #]
		solve( updateWaiterState(X, deployed($CurrentCid,$TableNum)) )
		solve( updateWaiterLoc(teatable($TableNum),X,Y))
		solve( engageTable($TableNum, $CurrentCid) ) // occupy table
		solve( roomstate(S) ) ifSolved { updateResource[# getCurSol("S").toString() #]  [#if(Debug) println("waiter coap updated\n${geResourceRep()}")#]  }
		emit attable : attable($CurrentCid)
	}
	Transition t0
		whenMsg placeorder -&gt; takeOrder
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//this state implements requirement "take"
	State takeOrder{//goto table + request relayorder
		println("waiter takeOrder")
		onMsg(moveKo : moveKo(X, Y)){//in case the move failed update where the robot has arrived
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(S,$X,$Y))
		}
		onMsg(placeorder : placeorder(CurrentCid)){
			[# CurrentCid = payloadArg(0) #]
			solve(updateWaiterState(X, goTakeOrder($CurrentCid)))
			}
		solve( teatable(Num, busy($CurrentCid), dirty) ) // find correct table
		[# val TableNum = getCurSol("Num").toString() #]
		solve(coordinatesTo(teatable($TableNum), OldX, OldY, X, Y))//move to teatable
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString()		#]
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	 [#if(Debug)#]println("waiter coap updated") }
	}
	Transition t0
		whenReply moveOk -&gt; takeOrderp2	 //now at the table
		whenReply moveKo -&gt; takeOrder  //retry
		
		
		
	State takeOrderp2{//at table + request relayorder
		solve( teatable(Num, busy($CurrentCid), dirty) ) // find correct table
		[# val TableNum = getCurSol("Num").toString() #]
		solve( updateWaiterLoc(teatable($TableNum),X,Y))
		solve( updateWaiterState(X, takingOrder($CurrentCid)) )
		request barman -m relayorder : relayorder($CurrentCid) //real task BL
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	 [#if(Debug)#]println("waiter coap updated") }
	}
	Transition t0
		whenReply orderready -&gt; serveOrder
		
		
		
		

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//this state implements requirement "serve"
	State serveOrder{//goto bar + goto table
		println("waiter serveOrder")
		onMsg(orderready : orderready(CurrentCid)){
			[# CurrentCid = payloadArg(0) #]
			solve(updateWaiterState(X, getOrder($CurrentCid)))
		}
		onMsg(moveKo : moveKo(X, Y)){//in case the move failed update where the robot has arrived
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(S,$X,$Y))
		}
		solve(coordinatesTo(barman, OldX, OldY, X, Y))//move to barman
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString()	#]		
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	 [#if(Debug)#]println("waiter coap updated") }
	}
	Transition t0
		whenReply moveOk -&gt; serveOrderp2	 //now at the table
		whenReply moveKo -&gt; serveOrder  //retry
		
		
	State serveOrderp2{//at bar, goto table
		onMsg(moveKo : moveKo(X, Y)){//in case the move failed update where the robot has arrived
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(_,$X,$Y))
		}
		onMsg(moveOk : moveOk(X,Y)){
			solve( updateWaiterState(X, bar($CurrentCid)) )
			solve( updateWaiterLoc(barman,X,Y) )
		}
		solve( teatable(Num, busy($CurrentCid), dirty) ) // find correct table
		[# val TableNum = getCurSol("Num").toString() #]
		solve(coordinatesTo(teatable($TableNum), OldX, OldY, X, Y))//move to teatable
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString() #]
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}		
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	 [#if(Debug)#]println("waiter coap updated") }	
	}
	Transition t0
		whenReply moveOk -&gt; serveOrderp3	 //now at the table
		whenReply moveKo -&gt; serveOrderp2  //retry
		
	State serveOrderp3{//at table
		onMsg(moveOk : moveOk(X,Y)){
			solve( teatable(Num, busy($CurrentCid), dirty) ) // find correct table
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   
				val TableNum = getCurSol("Num").toString()	#]
			solve( updateWaiterLoc(teatable($TableNum),$X,$Y) )
			solve( updateWaiterState(X, serving($CurrentCid)) )
			//-------------------------------------------
			emit delivered : delivered($CurrentCid) //just for simulation, in real life the client would see that the waiter has brought the tea
			//-------------------------------------------
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	}
	}
	Transition t0
		whenMsg payment -&gt; getPayment
		
		
		
		
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//this state implements requirements "collect" and "exit"
	State getPayment{//goto table + goto exitdoor
		println("waiter getPayment")
		onMsg(payment : payment(CurrentCid)){
			[# CurrentCid = payloadArg(0) #]
			solve(updateWaiterState(X, getPayment($CurrentCid)))
		}
		onMsg(moveKo : moveKo(X, Y)){//in case the move failed update where the robot has arrived
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(_,$X,$Y))
		}
		solve( teatable(Num, busy($CurrentCid), dirty) ) // find correct table
		[# val TableNum = getCurSol("Num").toString() #]
		solve(coordinatesTo(teatable($TableNum), OldX, OldY, X, Y))//move to teatable
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString()		#]
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	 [#if(Debug)#]println("waiter coap updated") }
	}
	Transition t0
		whenReply moveOk -&gt; getPaymentp2	 //now at the table
		whenReply moveKo -&gt; getPayment  //retry
		
	State getPaymentp2{//at table + goto exitdoor
		onMsg(moveOk : moveOk(X,Y)){
			emit paymentOk : paymentOk($CurrentCid)
			solve( teatable(Num, busy($CurrentCid), dirty) ) // find correct table
			[# val TableNum = getCurSol("Num").toString() #]
			solve( updateWaiterState(X, paymentatteatable($TableNum)) ) 
			solve( freeTable($TableNum, $CurrentCid) )
		}
		onMsg(moveKo : moveKo(X, Y)){//in case the move failed update where the robot has arrived
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(_,$X,$Y))
		}
		
		solve(coordinatesTo(exitdoor, OldX, OldY, X, Y))//move to exitdoor
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString()		#]
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	 [#if(Debug)#]println("waiter coap updated") }
	}
	Transition t0
		whenReply moveOk -&gt; escortToExit	 //goto exitdoor
		whenReply moveKo -&gt; getPaymentp2  //retry
		
	State escortToExit{//at exitdoor
		onMsg(moveOk : moveOk(X,Y)){
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			emit exitOk : exitOk($CurrentCid)
			solve( updateWaiterLoc(at(exitdoor),$X,$Y) )
			solve( updateWaiterState(X, at(exitdoor)) ) 
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	 [#if(Debug)#]println("waiter coap updated") }
	}
	Goto cleanTable
	
	
	
//----------------------------------------------------------------------------------------------------
	State cleanTable{
		println("waiter cleanTable")
		solve( dirtyTable(Num) )
		[# val TableNum = getCurSol("Num").toString() #]
		solve( updateWaiterState(X, gocleanteatable($TableNum)) ) 
		solve(coordinatesTo(teatable($TableNum), OldX, OldY, X, Y))//move to teatable
		//[#println(currentSolution)#]
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString()		#]
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #]	 [#if(Debug)#]println("waiter coap updated") }
		}
	Transition t0
		whenReply moveOk -&gt; doClean	 //now at the table
		whenReply moveKo -&gt; cleanTable  //retry
		
	State doClean{
		onMsg(moveOk : moveOk(X, Y)){
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(teatable(Num),$X,$Y))
			[# val TableNum = getCurSol("Num").toString() #]
			solve(updateWaiterState(X, cleaning($TableNum)))
		
			delayVar DelayTime // clean table, waiter cannot process incoming messages
			solve( cleanTable($TableNum) )
			solve( roomstate(S) ) ifSolved { updateResource[# getCurSol("S").toString() #]  [#if(Debug)#]println("waiter coap updated") }

		}
	}
	Transition t0
		whenTimeVar RestWaitTime -&gt; rest
		whenRequest table -&gt; checkTableAvail
		
		
		
		
//----------------------------------------------------------------------------------------------------		
	State rest{
		println("waiter rest")
		onMsg(moveKo : moveKo(X, Y)){//in case the move failed update where the robot has arrived
			[#  val X = payloadArg(0)
				val Y = payloadArg(1)   #]
			solve(updateWaiterLoc(_,$X,$Y))
			solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #] [#if(Debug)#]println("waiter coap updated") 	}
		}
		solve(coordinatesTo(home, OldX, OldY, X, Y))//move to teatable
		ifSolved { 
			[#  val OldX = getCurSol("OldX").toString()
				val OldY = getCurSol("OldY").toString()
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString()		#]
			request robot -m moveTo : moveTo($OldX, $OldY, $X, $Y)
		}
		}
	Transition t0
		whenReply moveOk -&gt; atHome	 //now at the table
		whenReply moveKo -&gt; rest  //retry
		
	State atHome{
		println("waiter athome")
		solve( updateWaiterState(X, rest ) )
		solve( updateWaiterLoc(home,X,Y) )
		solve( roomstate(S) )	ifSolved { 	updateResource[# getCurSol("S").toString() #] [#if(Debug)#]println("waiter coap updated") 	}
	}
	Transition t0
		whenRequest table -&gt; checkTableAvail
	
}

</pre> </td>
          <!-- KB -->
          <td>
            <pre> %===========================================
% tearoomkb.pl
%===========================================

%% ------------------------------------------ 
%% Configuration
%% ------------------------------------------ 

stepTime(600).
stepFailWaitTime(10000).
%%debug(x).
debugwaiter(x).

%% ------------------------------------------ 
%% Positions
%% ------------------------------------------ 

pos( home, 0, 0 ).
pos( entrancedoor, 1, 4 ).
pos( exitdoor, 5, 4 ).
pos( barman, 5, 0 ).
pos( teatable(1), 2, 2 ).
pos( teatable(2), 4, 2 ).
 
%% ------------------------------------------ 
%% Teatables
%% teatable(Num, {free, reserved(Cid), busy(Cid)}, {clean, dirty}).
%% ------------------------------------------ 
teatable( 1, free, clean ).
teatable( 2, free, clean ). 

tableavailable(N):- teatable(N,	free, clean ).

numavailabletables(N) :-
	findall( N, teatable( N, free, clean ), NList),
	length( NList, N ).

reserveTable(N,Cid)	 :-
	retract( teatable( N, free, clean ) ) ,
	!,
	assert( teatable( N, reserved(Cid), clean ) ).
	
reserveTable(_,_).	

%%reservedTable(N, Cid, Clean) :- teatable( N, reserved(Cid), Clean ). %%tavolo prenotato da Cid

engageTable(N,Cid)	 :-
	retract( teatable( N, reserved(Cid), clean ) ) ,
	!,
	assert( teatable( N, busy(Cid), dirty ) ).

freeTable(N, Cid) :-
	retract( teatable( N, busy(Cid), dirty ) ),
	!,
	assert( teatable( N, free, dirty ) ).
freeTable(_,_).	
	
dirtyTable(Num) :- teatable(Num, free, dirty).	
	
cleanTable(N)	 :-
	%% stdout &lt;- println( tearoomkb_cleanTable(N) ),
	retract( teatable( N, free, dirty ) ) ,
	!,
	asserta( teatable( N, free, clean ) ).
cleanTable(N).	
 
stateOfTeatable( [teatable1(V1,V2)] ) :-
	teatable( 1, V1, V2 ).
	
stateOfTeatables( [teatable(1, V1, V2),teatable(2, V3, V4)] ) :-
	teatable( 1, V1, V2 ),
	teatable( 2, V3, V4 ).

%% ------------------------------------------ 
%% Waiter
%% ------------------------------------------ 

waiter( rest, 0, 0 ).	

%%update textual state, keep map location
updateWaiterState(Old,New) :- 
	retract(waiter(Old, X, Y)),
	!,
	assert(waiter(New, X, Y)).

%%keep textual state, update map location (either give PositionName or coordinates of it)
updateWaiterLoc(PositionName, NewX, NewY) :- 
	pos(PositionName, NewX, NewY),
	!,
	retract(waiter(State, _, _)),
	!,
	assert(waiter(State, NewX, NewY)).

%%keep textual state, update map location to any location
updateWaiterLoc(PositionName, NewX, NewY) :- 
	retract(waiter(State, _, _)),
	!,
	assert(waiter(State, NewX, NewY)).
	
%%update textual state w/ position name, update map location to the position location
updateWaiterLoc(PositionName) :- 
	pos(PositionName, X, Y),
	!,
	retract(waiter(_, _, _)),
	!,
	assert(waiter(PositionName, X, Y)).
	
%%get both waiter and destination coordinates from destination name
coordinatesTo(PositionName, WX, WY, X, Y) :-
	waiter(_, WX, WY),
	pos(PositionName, X, Y).
%% ------------------------------------------ 
%% Hall
%% ------------------------------------------ 
hall(free).

freeHall(X) :- 
retract(hall(free)),
!,
assert(hall(busy)).

occupyHall(X) :- 
retract(hall(busy)),
!,
assert(hall(free)).


%% ------------------------------------------ 
%% Room as a whole
%% ------------------------------------------ 
roomstate(  state( waiter(S,X,Y), tables(V) )  ):-
	 waiter(S,X,Y), stateOfTeatables(V) .
	 
	

</pre> </td>
        </tr>
      </tbody>
    </table>
    <h3> Stato </h3>
    <div> Lo stato è mantenuto unicamente dall'attore Waiter; la posizione
      fisica del ddr waiter è aggiornata solamente al termine dell'esecuzione
      dei piani (sia in caso di successo che di fallimento); ogni cambiamento di
      stato viene reso disponibile tramite protocollo CoAP. <br>
      Per questo motivo l'interfaccia web è sufficiente che osservi tramite
      protocollo CoAP l'attore Waiter per visualizzare lo stato corrente della
      tearoom.</div>
    <br>
    <h3> Frontend web, partendo da quanto visto <a href="http://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/iss2020LabBo/master/robotWeb2020/userdocs/RobotWebonSpring.html">a
        lezione</a></h3>
    <h4> Server </h4>
    <div> Uso di:
      <ul>
        <li>Spring Boot per velocizzare lo sviluppo, nascondendo il vero server
          Web e ottenendo accesso a varie funzioni, tra cui gestione
          semplificata del protocollo <kc>WebSocket</kc> che permette di
          interagire con i client web utilizzando <kc>modello push</kc> invece
          che pull (aggiornamento automatico della pagina sul client web);</li>
        <li>libreria <em>it.unibo.kactor</em> per la gestione della logica
          applicativa (e.g. creazione corretta di messaggi);</li>
        <li>protocollo MQTT per inviare messaggi al sistema come entità aliena.</li>
      </ul>
    </div>
    <h4> Client </h4>
    <div> Uso di:
      <ul>
        <li>Javascript e jQuery per modificare il DOM della pagina;</li>
        <li>Librerie stomp + sockjs per realizzare WebSocket lato client.</li>
      </ul>
    </div>
    <p> <img src="https://raw.githubusercontent.com/marcogozzi/ISS-2020-Docs/master/webapppng.png"
        style="border: 5px solid #555;" width="75%"> </p>
    <br>
    <h2> Sprint review </h2>
    <div>
      <ul>
        <li>Utilizzando il robot virtuale introdotto a lezione, la precisione
          dei movimenti è scarsa e richede numerosi interventi manuali; nel
          prossimo sprint è opportuno cercare di mitigare questo difetto;</li>
        <li>può essere opportuno fornire tramite l'interfaccia web alcuni
          comandi per comandare fisicamente il robot in modo che, in
          caso di disallineamento dovuto a imprecisione dei movimenti, il
          manager possa risolvere remotamente la situazione;</li>
        <li>la presenza di un unico sensore (di collisione) può non essere sufficiente nel robot fisico per garantire la precisione richiesta.</li>
      </ul>
    </div>
    <br>
    <br>
    <br>
    <hr>
    <div style="background-color: rgba(86, 56, 253, 0.7); width: 40%; text-align: left; color: white;">By
      Marco Gozzi<br>
      email: marco.gozzi3@studio.unibo.it <br>
      <img src="https://raw.githubusercontent.com/marcogozzi/ISS-2020-Docs/master/io.png"
        alt="github.com/marcogozzi/" align=""> </div>
  </body>
</html>
